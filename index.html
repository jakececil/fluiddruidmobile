<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fluid Visualizer â€” MOBILE ONLY</title>
  <style>
    :root{ --ink:#d9ecff; --ui:#11161f; --edge:#1c2433; --accent:#7c5cff; }
    html, body { height:100%; margin:0; }
    body { background:#0b0f14; color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; overflow:hidden; }

    /* Layout: canvas full screen, floating bottom bar; controls open as full-sheet overlay */
    #stage { position:fixed; inset:0; }
    canvas { position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }
    #hud { position:absolute; top:10px; left:12px; font-size:12px; color:#b9c6e4; background:rgba(10,14,22,.45); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.08); z-index:2 }

    #bar { position:fixed; left:0; right:0; bottom:0; height:56px; display:flex; align-items:center; justify-content:space-between; padding:0 12px; gap:10px; background:linear-gradient(180deg, rgba(10,14,22,.2), rgba(10,14,22,.55)); backdrop-filter: blur(8px); border-top:1px solid rgba(255,255,255,.08); z-index:5 }
    #bar button { appearance:none; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:#162132; color:var(--ink); padding:10px 12px; font-weight:700; }

    /* Full-screen controls sheet */
    #sheet { position:fixed; left:0; right:0; bottom:0; top:25%; background:linear-gradient(180deg, rgba(17,22,31,.98), rgba(17,22,31,.94)); transform: translateY(100%); transition: transform .22s ease; border-top:1px solid rgba(255,255,255,.08); border-radius:16px 16px 0 0; z-index:6; display:flex; flex-direction:column; }
    body.sheet-open #sheet { transform: translateY(0); }
    #drag { height:28px; display:flex; align-items:center; justify-content:center; }
    #drag .bar { width:48px; height:5px; border-radius:999px; background:rgba(200,220,255,.35); }
    #content { flex:1; overflow:auto; padding:10px 14px 20px; }
    .row{ margin:10px 0 14px }
    .row label{ display:flex; align-items:center; justify-content:space-between; gap:10px; font-size:13px; color:#c7d3ea }
    .grid{ display:grid; grid-template-columns:1fr 1fr; gap:10px }
    input[type="range"]{ width:100% }
    input[type="color"]{ width:100%; height:36px; border:none; background:#0000 }
    .val{ font-variant-numeric: tabular-nums; color:#a9b7d9; min-width:70px; text-align:right }

    /* While drawing, prevent Safari overscroll without blocking UI */
    body.drawing { overscroll-behavior: contain; }
  </style>
</head>
<body>
  <div id="stage">
    <canvas id="c"></canvas>
    <div id="hud">FPS: <span id="fps">0</span> | Advection: <span id="adv">MacCormack</span></div>
  </div>

  <div id="bar">
    <button id="clear">Clear</button>
    <button id="toggle">Controls</button>
  </div>

  <section id="sheet" aria-label="Controls">
    <div id="drag"><div class="bar"></div></div>
    <div id="content">
      <div class="row"><label>Resolution <span class="val"><span id="nDisplay"></span>Ã—<span id="nDisplayY"></span></span></label><input id="n" type="range" min="48" max="220" step="4" value="144"></div>
      <div class="row grid">
        <div><label>Viscosity <span class="val" id="viscVal">0.0002</span></label><input id="visc" type="range" min="0" max="0.01" step="0.0001" value="0.0002"></div>
        <div><label>Diffusion <span class="val" id="diffVal">0.0001</span></label><input id="diff" type="range" min="0" max="0.01" step="0.0001" value="0.0001"></div>
      </div>
      <div class="row grid">
        <div><label>Time Step <span class="val" id="dtVal">0.016</span></label><input id="dt" type="range" min="0.006" max="0.033" step="0.001" value="0.016"></div>
        <div><label>Vorticity <span class="val" id="vortVal">18</span></label><input id="vort" type="range" min="0" max="40" step="1" value="18"></div>
      </div>
      <div class="row grid">
        <div><label>Brush <span class="val" id="brushVal">14</span></label><input id="brush" type="range" min="1" max="100" step="1" value="14"></div>
        <div><label>Force <span class="val" id="forceVal">900</span></label><input id="force" type="range" min="10" max="2200" step="10" value="900"></div>
      </div>
      <div class="row grid">
        <div><label>Gravity Y <span class="val" id="gyVal">0</span></label><input id="gy" type="range" min="-200" max="200" step="1" value="0"></div>
        <div><label>Buoyancy <span class="val" id="buoyVal">0.10</span></label><input id="buoy" type="range" min="0" max="1" step="0.01" value="0.10"></div>
      </div>
      <div class="row">
        <label>Ink Color</label>
        <div class="grid">
          <input id="ink" type="color" value="#66ccff">
          <button id="rainbow">Cycle ðŸŽ </button>
        </div>
      </div>
      <div class="row grid">
        <label class="grid" style="align-items:center"><span>Vorticity</span><input id="confToggle" type="checkbox" checked></label>
        <label class="grid" style="align-items:center"><span>MacCormack</span><input id="advectMAC" type="checkbox" checked></label>
      </div>
      <div class="row grid">
        <label class="grid" style="align-items:center"><span>Wrap Edges</span><input id="edges" type="checkbox"></label>
        <label class="grid" style="align-items:center"><span>Pretty âœ¨</span><input id="pretty" type="checkbox" checked></label>
      </div>
      <div class="row"><label>Color Cycle Speed <span class="val" id="colorSpeedVal">600</span></label><input id="colorSpeed" type="range" min="0" max="2000" step="20" value="600"></div>
    </div>
  </section>

  <script>
    // ===== Mobile-first core =====
    const clamp=(x,a,b)=>x<a?a:(x>b?b:x);
    let hue=200, hueVel=600;

    class Fluid {
      constructor(n, wrap=false){ this.setResolution(n, wrap); this.diff=1e-4; this.visc=2e-4; this.dt=0.016; this.vort=18; this.confine=true; this.buoy=0.1; this.advectMac=true; this.gravY=0; }
      setResolution(n, wrap){ this.n=n|0; this.wrap=!!wrap; const N=this.n, sz=(N+2)*(N+2); this.u=new Float32Array(sz); this.v=new Float32Array(sz); this.u0=new Float32Array(sz); this.v0=new Float32Array(sz); this.r=new Float32Array(sz); this.g=new Float32Array(sz); this.b=new Float32Array(sz); this.r0=new Float32Array(sz); this.g0=new Float32Array(sz); this.b0=new Float32Array(sz); this.tmp=new Float32Array(sz); }
      IX(x,y){ return x + (this.n+2)*y; }
      addSource(x,s,dt){ for(let i=0;i<x.length;i++) x[i]+=dt*s[i]; }
      setBnd(b,x){ const N=this.n; for(let i=1;i<=N;i++){ x[this.IX(0,i)]=this.wrap?x[this.IX(N,i)]:(b===1?-x[this.IX(1,i)]:x[this.IX(1,i)]); x[this.IX(N+1,i)]=this.wrap?x[this.IX(1,i)]:(b===1?-x[this.IX(N,i)]:x[this.IX(N,i)]); x[this.IX(i,0)]=this.wrap?x[this.IX(i,N)]:(b===2?-x[this.IX(i,1)]:x[this.IX(i,1)]); x[this.IX(i,N+1)]=this.wrap?x[this.IX(i,1)]:(b===2?-x[this.IX(i,N)]:x[this.IX(i,N)]); } x[this.IX(0,0)]=0.5*(x[this.IX(1,0)]+x[this.IX(0,1)]); x[this.IX(0,N+1)]=0.5*(x[this.IX(1,N+1)]+x[this.IX(0,N)]); x[this.IX(N+1,0)]=0.5*(x[this.IX(N,0)]+x[this.IX(N+1,1)]); x[this.IX(N+1,N+1)]=0.5*(x[this.IX(N,N+1)]+x[this.IX(N+1,N)]); }
      linSolve(b,x,x0,a,c){ const N=this.n, cr=1/c; for(let k=0;k<20;k++){ for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ x[this.IX(i,j)] = (x0[this.IX(i,j)] + a*( x[this.IX(i-1,j)] + x[this.IX(i+1,j)] + x[this.IX(i,j-1)] + x[this.IX(i,j+1)] ))*cr; } } this.setBnd(b,x);} }
      diffuse(b,x,x0,diff,dt){ const a=dt*diff*this.n*this.n; this.linSolve(b,x,x0,a,1+4*a); }
      advect(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N; for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; } else { if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5; if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; d[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]); } } this.setBnd(b,d); }
      advectMacCormack(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N, phiHat=this.tmp; for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; } else { if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5; if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; phiHat[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);} } this.setBnd(b,phiHat); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i+dt0*u[this.IX(i,j)], y=j+dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; } else { if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5; if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; const phiBar = s0*(t0*phiHat[this.IX(i0,j0)] + t1*phiHat[this.IX(i0,j1)]) + s1*(t0*phiHat[this.IX(i1,j0)] + t1*phiHat[this.IX(i1,j1)]); let corr=0.5*(d0[this.IX(i,j)]-phiBar); const lo=Math.min(d0[this.IX(i,j)], phiHat[this.IX(i,j)]), hi=Math.max(d0[this.IX(i,j)], phiHat[this.IX(i,j)]); d[this.IX(i,j)] = Math.max(lo, Math.min(hi, phiHat[this.IX(i,j)] + corr)); } } this.setBnd(b,d); }
      project(u,v,p,div){ const N=this.n, IX=this.IX.bind(this); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ div[IX(i,j)] = -0.5*( u[IX(i+1,j)]-u[IX(i-1,j)] + v[IX(i,j+1)]-v[IX(i,j-1)] )/N; p[IX(i,j)]=0; } } this.setBnd(0,div); this.setBnd(0,p); this.linSolve(0,p,div,1,4); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)]-p[IX(i-1,j)]); v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)]-p[IX(i,j-1)]); } } this.setBnd(1,u); this.setBnd(2,v); }
      vorticityConfinement(u,v,eps){ const N=this.n, IX=this.IX.bind(this); for(let i=2;i<=N-1;i++){ for(let j=2;j<=N-1;j++){ const dw_dx=(Math.abs(v[IX(i+1,j)]-v[IX(i-1,j)])*0.5), dw_dy=(Math.abs(u[IX(i,j+1)]-u[IX(i,j-1)])*0.5); const len=Math.sqrt(dw_dx*dw_dx+dw_dy*dw_dy)+1e-6; const Nx=dw_dx/len, Ny=dw_dy/len; const w=(v[IX(i+1,j)]-v[IX(i-1,j)]-(u[IX(i,j+1)]-u[IX(i,j-1)]))*0.5; this.u[IX(i,j)] += eps*(Ny*w); this.v[IX(i,j)] += eps*(-Nx*w); } } this.setBnd(1,this.u); this.setBnd(2,this.v); }
      step(){ const dt=this.dt, u=this.u,v=this.v,u0=this.u0,v0=this.v0, r=this.r,g=this.g,b=this.b, r0=this.r0,g0=this.g0,b0=this.b0; if(this.gravY!==0){ for(let i=0;i<u.length;i++) v[i]+=this.gravY*dt/this.n; } if(this.buoy>0){ for(let i=0;i<r.length;i++){ const d=(r[i]+g[i]+b[i])*(1/3); v[i]+=-this.buoy*d*dt; } } this.diffuse(1,u0,u,this.visc,dt); this.diffuse(2,v0,v,this.visc,dt); this.project(u0,v0,u,v); if(this.advectMac){ this.advectMacCormack(1,u,u0,u0,v0,dt); this.advectMacCormack(2,v,v0,u0,v0,dt); } else { this.advect(1,u,u0,u0,v0,dt); this.advect(2,v,v0,u0,v0,dt); } this.project(u,v,u0,v0); if(this.confine && this.vort>0){ this.vorticityConfinement(u,v,this.vort*dt*0.0015); } this.diffuse(0,r0,r,this.diff,dt); this.diffuse(0,g0,g,this.diff,dt); this.diffuse(0,b0,b,this.diff,dt); if(this.advectMac){ this.advectMacCormack(0,r,r0,u,v,dt); this.advectMacCormack(0,g,g0,u,v,dt); this.advectMacCormack(0,b,b0,u,v,dt); } else { this.advect(0,r,r0,u,v,dt); this.advect(0,g,g0,u,v,dt); this.advect(0,b,b0,u,v,dt); } const decay=0.9995; for(let i=0;i<r.length;i++){ r[i]*=decay; g[i]*=decay; b[i]*=decay; } u0.fill(0); v0.fill(0); r0.fill(0); g0.fill(0); b0.fill(0); }
    }

    // ===== Rendering =====
    const canvas=document.getElementById('c');
    const ctx=canvas.getContext('2d');
    function resizeCanvas(){ const dpr=Math.min(2, window.devicePixelRatio||1); const {clientWidth:w, clientHeight:h}=canvas; canvas.width=Math.max(1, Math.floor(w*dpr)); canvas.height=Math.max(1, Math.floor(h*dpr)); }
    function rgb(r,g,b){ return `rgb(${(r*255)|0},${(g*255)|0},${(b*255)|0})`; }

    // ===== UI wiring =====
    const fluid=new Fluid(144);
    const el=id=>document.getElementById(id);
    const n=el('n'), visc=el('visc'), diff=el('diff'), dt=el('dt'), vort=el('vort');
    const brush=el('brush'), force=el('force'), gy=el('gy'), buoy=el('buoy');
    const ink=el('ink'); const confToggle=el('confToggle'); const advectMAC=el('advectMAC'); const edges=el('edges'); const pretty=el('pretty');
    const clearBtn=el('clear'); const toggleBtn=el('toggle'); const rainbow=el('rainbow');
    const colorSpeed=el('colorSpeed'); const nDisplay=el('nDisplay'), nDisplayY=el('nDisplayY');
    const viscVal=el('viscVal'), diffVal=el('diffVal'), dtVal=el('dtVal'), vortVal=el('vortVal');
    const brushVal=el('brushVal'), forceVal=el('forceVal'), gyVal=el('gyVal'), buoyVal=el('buoyVal');
    const fpsEl=el('fps'); const advEl=el('adv');

    function syncLabels(){ nDisplay.textContent=fluid.n; nDisplayY.textContent=fluid.n; viscVal.textContent=(+visc.value).toFixed(4); diffVal.textContent=(+diff.value).toFixed(4); dtVal.textContent=(+dt.value).toFixed(3); vortVal.textContent=(+vort.value).toString(); brushVal.textContent=brush.value; forceVal.textContent=force.value; gyVal.textContent=gy.value; buoyVal.textContent=(+buoy.value).toFixed(2); advEl.textContent=advectMAC.checked? 'MacCormack':'Semi-Lagrangian'; }
    function applyUI(){ fluid.visc=+visc.value; fluid.diff=+diff.value; fluid.dt=+dt.value; fluid.vort=+vort.value; fluid.confine=confToggle.checked; fluid.advectMac=advectMAC.checked; fluid.wrap=edges.checked; fluid.buoy=+buoy.value; fluid.gravY=+gy.value/1000; hueVel=+colorSpeed.value; syncLabels(); }
    [visc,diff,dt,vort,brush,force,gy,buoy,confToggle,advectMAC,edges,pretty,colorSpeed].forEach(x=>x.addEventListener('input', applyUI, {passive:true}));
    n.addEventListener('change', ()=>{ fluid.setResolution(+n.value, edges.checked); syncLabels(); });
    clearBtn.addEventListener('click', ()=>{ fluid.u.fill(0); fluid.v.fill(0); fluid.r.fill(0); fluid.g.fill(0); fluid.b.fill(0); });
    rainbow.addEventListener('click', ()=>{ const sign=Math.random()<.5?-1:1; hueVel=(Math.random()*1200+400)*sign; colorSpeed.value=Math.abs(hueVel); syncLabels(); });
    toggleBtn.addEventListener('click', ()=>{ document.body.classList.toggle('sheet-open'); });

    // ===== Interaction (TOUCH-ONLY PATH) =====
    const mouse={x:0,y:0,px:0,py:0,down:false,alt:false};
    function mapToGrid(x,y){ const r=canvas.getBoundingClientRect(); mouse.px=mouse.x; mouse.py=mouse.y; mouse.x=((x-r.left)/r.width)*(fluid.n+2); mouse.y=((y-r.top)/r.height)*(fluid.n+2); }

    // Important: use non-passive + preventDefault so Safari doesn't scroll/zoom
    const lock=()=>document.body.classList.add('drawing');
    const unlock=()=>document.body.classList.remove('drawing');

    canvas.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; if(!t) return; mouse.down=true; lock(); mapToGrid(t.clientX, t.clientY); e.preventDefault(); paint({pointerType:'touch'}); }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{ if(!mouse.down) return; const t=e.touches[0]; if(!t) return; mapToGrid(t.clientX, t.clientY); e.preventDefault(); paint({pointerType:'touch'}); }, {passive:false});
    canvas.addEventListener('touchend', ()=>{ mouse.down=false; unlock(); }, {passive:false});
    canvas.addEventListener('touchcancel', ()=>{ mouse.down=false; unlock(); }, {passive:false});

    // Mouse fallback so this build still works on desktop for testing
    canvas.addEventListener('mousedown', (e)=>{ mouse.down=true; mapToGrid(e.clientX,e.clientY); paint({pointerType:'mouse'}); });
    window.addEventListener('mousemove', (e)=>{ if(!mouse.down) return; mapToGrid(e.clientX,e.clientY); paint({pointerType:'mouse'}); });
    window.addEventListener('mouseup', ()=>{ mouse.down=false; });

    function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }
    function hsl2rgb(h,s,l){ const a=s*Math.min(l,1-l); const f=n=>{const k=(n+h*12)%12; return l-a*Math.max(-1,Math.min(k-3,9-k,1));}; return [f(0),f(8),f(4)]; }

    function paint(e){ const N=fluid.n, IX=fluid.IX.bind(fluid); const r=fluid.r0,g=fluid.g0,b=fluid.b0,u=fluid.u0,v=fluid.v0; const big = (e && e.pointerType==='touch')? 2.2 : 1.0; const bs=(+brush.value)*big; const dx=(mouse.x-mouse.px)*(+force.value)/500; const dy=(mouse.y-mouse.py)*(+force.value)/500; let col=hexToRgb(ink.value); if(pretty.checked){ hue=(hue+hueVel*fluid.dt)%360; const c=hsl2rgb(hue/360,0.75,0.55); col={r:c[0]*255,g:c[1]*255,b:c[2]*255}; }
      for(let i=-bs;i<=bs;i++) for(let j=-bs;j<=bs;j++){
        const x=(mouse.x|0)+i, y=(mouse.y|0)+j; if(x<1||y<1||x>N||y>N) continue; const w=1-Math.hypot(i,j)/bs; if(w<=0) continue; const idx=IX(x,y);
        u[idx]+=dx*w; v[idx]+=dy*w; r[idx]+=(col.r/255)*w*1.1; g[idx]+=(col.g/255)*w*1.1; b[idx]+=(col.b/255)*w*1.1; }
    }

    // ===== Render loop =====
    function render(){ const N=fluid.n, IX=fluid.IX.bind(fluid); const cw=canvas.width, ch=canvas.height; const cellX=cw/(N+2), cellY=ch/(N+2); ctx.clearRect(0,0,cw,ch); const rr=fluid.r, gg=fluid.g, bb=fluid.b; for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ const r=rr[IX(i,j)], g=gg[IX(i,j)], b=bb[IX(i,j)]; if(r+g+b<1e-4) continue; ctx.fillStyle=rgb(r,g,b); ctx.fillRect((i-0.5)*cellX,(j-0.5)*cellY, cellX+1, cellY+1); } } }
    let last=performance.now(), frames=0, fps=0, acc=0;
    function loop(ts){ const d=(ts-last)/1000; last=ts; acc+=d; frames++; if(acc>0.5){ fps=Math.round(frames/acc*2)/2; fpsEl.textContent=fps; frames=0; acc=0; }
      fluid.addSource(fluid.u,fluid.u0,1); fluid.addSource(fluid.v,fluid.v0,1); fluid.addSource(fluid.r,fluid.r0,1); fluid.addSource(fluid.g,fluid.g0,1); fluid.addSource(fluid.b,fluid.b0,1);
      fluid.step(); render(); requestAnimationFrame(loop); }

    // ===== Sheet drag to close (tap handle or drag down) =====
    const sheet=document.getElementById('sheet'); const drag=document.getElementById('drag');
    let dragging=false, startY=0, startT=0;
    const curT=()=>{ const st=getComputedStyle(sheet).transform; if(st&&st!=='none'){ const m=new DOMMatrix(st); return m.m42; } return 0; };
    drag.addEventListener('touchstart', (e)=>{ dragging=true; startY=e.touches[0].clientY; startT=curT(); e.preventDefault(); }, {passive:false});
    window.addEventListener('touchmove', (e)=>{ if(!dragging) return; const py=e.touches[0].clientY; const dy=py-startY; sheet.style.transform=`translateY(${Math.max(0, startT+dy)}px)`; e.preventDefault(); }, {passive:false});
    window.addEventListener('touchend', ()=>{ if(!dragging) return; dragging=false; const open = sheet.getBoundingClientRect().top < innerHeight*0.65; document.body.classList.toggle('sheet-open', open); sheet.style.transition='transform .2s ease'; sheet.style.transform = open? 'translateY(0)' : 'translateY(100%)'; setTimeout(()=>sheet.style.transition='', 220); }, {passive:false});

    // ===== Boot =====
    const ro=new ResizeObserver(resizeCanvas); ro.observe(document.getElementById('stage')); addEventListener('resize', resizeCanvas);
    resizeCanvas(); applyUI(); syncLabels(); document.body.classList.add('sheet-open'); // start with controls visible on first load
    requestAnimationFrame(loop);

    // ===== Smoke test (no visual diff) =====
    (function selfTest(){ try {
      console.assert(document.getElementById('fps')===fpsEl, 'fpsEl wired');
      const f=new Fluid(16); f.u0.fill(1); f.addSource(f.u,f.u0,1); console.assert(Math.abs(f.u[10]-1)<1e-6,'addSource ok');
      // ensure paint path affects sources
      const s=fluid.u0.reduce((a,v)=>a+v,0); mouse.x=8; mouse.y=8; mouse.px=7; mouse.py=8; paint({pointerType:'touch'}); const s2=fluid.u0.reduce((a,v)=>a+v,0); console.assert(s2>s, 'paint injected');
    } catch(e){ console.warn('SelfTest', e); } })();
  </script>
</body>
</html>
