<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fluid Dynamics â€” Mobile Safari (Ref Logic)</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#111827cc;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--accent2:#a78bfa;--chip:#1f2937;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased}
    #app{position:fixed;inset:0;display:flex;flex-direction:column}
    header{display:flex;align-items:center;gap:.6rem;padding:.7rem env(safe-area-inset-right) .7rem env(safe-area-inset-left)}
    header h1{font-size:1.05rem;margin:0;letter-spacing:.1px;font-weight:700}
    header .fps{margin-left:auto;font-variant-numeric:tabular-nums;opacity:.85}
    #canvasWrap{position:relative;flex:1;min-height:240px}
    canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none;background:#070a0f;display:block}

    #fab{position:fixed;right:env(safe-area-inset-right);bottom:calc(1rem + env(safe-area-inset-bottom));z-index:10}
    #fab button{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#fff;border:none;border-radius:999px;padding:.9rem 1.05rem;box-shadow:0 10px 25px #0008;font-weight:700}

    #sheet{position:fixed;left:0;right:0;bottom:0;transform:translateY(100%);transition:.35s transform ease;z-index:20}
    #sheet.open{transform:translateY(0)}
    .sheet-contents{background:var(--panel);backdrop-filter:blur(10px);border-radius:16px 16px 0 0;box-shadow:0 -15px 40px #000c;padding:12px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left)}
    .drag{width:44px;height:4px;background:#ffffff35;border-radius:2px;margin:6px auto 10px}
    .row{display:flex;align-items:center;gap:.5rem;margin:8px 0}
    .row label{flex:0 0 44%;font-size:.86rem;color:var(--muted)}
    .row input[type=range]{flex:1}
    .switch{display:flex;align-items:center;gap:.5rem;margin:6px 0}
    .chips{display:flex;flex-wrap:wrap;gap:.4rem;margin-top:.25rem}
    .chip{background:var(--chip);border-radius:999px;padding:.45rem .65rem;font-size:.82rem}
    .controls{max-height:56vh;overflow:auto;-webkit-overflow-scrolling:touch}
    .btns{display:flex;gap:.5rem;margin-top:8px;flex-wrap:wrap}
    .btn{flex:1;background:#1f2937;border:1px solid #ffffff22;border-radius:10px;padding:.6rem .8rem;color:#fff;text-align:center}
    .btn.full{flex-basis:100%}
    .small{font-size:.8rem;color:var(--muted)}
    .status{margin-left:.6rem;opacity:.8;font-size:.82rem}
    .err{color:#fca5a5}
    .ok{color:#34d399}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>ðŸŒˆ Fluid Dynamics Visualizer</h1>
      <div class="status" id="testStatus"></div>
      <div class="fps" id="fps">-- fps</div>
    </header>
    <div id="canvasWrap">
      <canvas id="view" aria-label="Fluid simulation"></canvas>
    </div>
  </div>

  <div id="fab"><button id="toggle">Controls â–´</button></div>
  <div id="sheet" aria-live="polite" aria-expanded="false">
    <div class="sheet-contents" id="sheetC">
      <div class="drag"></div>
      <div class="controls" id="controls">
        <div class="row"><label>Resolution</label><input id="res" type="range" min="64" max="256" step="32" value="160"></div>
        <div class="row"><label>Time Step</label><input id="dt" type="range" min="0.004" max="0.033" step="0.001" value="0.016"></div>
        <div class="row"><label>Viscosity</label><input id="visc" type="range" min="0" max="0.003" step="0.0001" value="0.0002"></div>
        <div class="row"><label>Diffusion</label><input id="diff" type="range" min="0" max="0.003" step="0.0001" value="0.0002"></div>
        <div class="row"><label>Vorticity</label><input id="vort" type="range" min="0" max="80" step="1" value="45"></div>
        <div class="row"><label>Brush Size</label><input id="brush" type="range" min="6" max="64" step="1" value="26"></div>
        <div class="row"><label>Force</label><input id="force" type="range" min="50" max="1500" step="10" value="900"></div>
        <div class="row"><label>Gravity</label><input id="grav" type="range" min="-900" max="900" step="10" value="120"></div>
        <div class="row"><label>Buoyancy</label><input id="buoy" type="range" min="-2" max="2" step="0.05" value="0.2"></div>
        <div class="switch"><input id="macc" type="checkbox" checked> <label for="macc">MacCormack advection</label></div>
        <div class="switch"><input id="wrap" type="checkbox"> <label for="wrap">Wrap edges</label></div>
        <div class="switch"><input id="pretty" type="checkbox" checked> <label for="pretty">Pretty additives (RGB dye)</label></div>
        <div class="chips">
          <span class="chip" data-preset="calm">Calm Pool</span>
          <span class="chip" data-preset="storm">Stormy</span>
          <span class="chip" data-preset="smoke">Smoky Room</span>
          <span class="chip" data-preset="nebula">Nebula</span>
          <span class="chip" data-preset="ink">Ink Drop</span>
          <span class="chip" data-preset="psy">Psychedelia</span>
        </div>
        <div class="btns">
          <div class="btn" id="clear">Clear</div>
          <div class="btn" id="pause">Pause â–Œâ–Œ</div>
          <div class="btn full" id="diag">Run Diagnostics</div>
        </div>
        <div class="small">Tip: drag to paint dye & add force. Long-press without moving to just add force (wind). If it jitters on older phones, reduce resolution.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ============================
  // Helpers
  // ============================
  const clamp=(x,a,b)=>x<a?a:(x>b?b:x);
  function q(s){ return document.querySelector(s); }
  function on(sel,evt,fn){ document.querySelectorAll(sel).forEach(el=>el.addEventListener(evt,()=>fn(el))); }
  function hsl(h,s,l){ const c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs((h/60)%2-1)), m=l-c/2; let r=0,g=0,b=0; if(0<=h&&h<60){r=c;g=x;} else if(60<=h&&h<120){r=x;g=c;} else if(120<=h&&h<180){g=c;b=x;} else if(180<=h&&h<240){g=x;b=c;} else if(240<=h&&h<300){r=x;b=c;} else {r=c;b=x;} return [r+m,g+m,b+m]; }

  // Color cycling (kept for parity with reference)
  let hue=200, hueVel=240;

  // ============================
  // UI elements
  // ============================
  const C = document.getElementById('view');
  const W = C.getContext('2d', {alpha:false, desynchronized:true});
  const fpsEl = document.getElementById('fps');
  const statusEl = document.getElementById('testStatus');

  const ui = {
    res:q('#res'), dt:q('#dt'), visc:q('#visc'), diff:q('#diff'), vort:q('#vort'), brush:q('#brush'),
    force:q('#force'), grav:q('#grav'), buoy:q('#buoy'), macc:q('#macc'), wrap:q('#wrap'),
    pretty:q('#pretty'), clear:q('#clear'), pause:q('#pause'), diag:q('#diag')
  };

  // Bottom sheet
  const sheet=q('#sheet'); const toggleBtn=q('#toggle'); let open=false;
  const setSheet=v=>{ open=v; sheet.classList.toggle('open',open); sheet.setAttribute('aria-expanded', String(open)); toggleBtn.textContent = open?'Controls â–¾':'Controls â–´'; };
  toggleBtn.addEventListener('click', ()=>setSheet(!open)); q('.drag').addEventListener('click', ()=>setSheet(!open));

  // DPI-aware resize
  function resize(){ const dpr=Math.max(1, Math.min(window.devicePixelRatio||1, 2)); const rect=C.parentElement.getBoundingClientRect(); C.width=Math.max(2,rect.width*dpr|0); C.height=Math.max(2,rect.height*dpr|0); W.setTransform(dpr,0,0,dpr,0,0); }
  new ResizeObserver(resize).observe(document.getElementById('canvasWrap')); resize();

  // ============================
  // Fluid (ported from your reference)
  // ============================
  class Fluid{
    constructor(n, wrap=false){ this.setResolution(n, wrap); this.diff=1e-4; this.visc=2e-4; this.dt=0.016; this.vort=15; this.confine=true; this.buoy=0.1; this.advectMac=true; this.gravY=0; this.pretty=true; }
    setResolution(n, wrap){ this.n=n|0; this.wrap=!!wrap; const N=this.n, size=(N+2)*(N+2); this.u=new Float32Array(size); this.v=new Float32Array(size); this.u0=new Float32Array(size); this.v0=new Float32Array(size); this.r=new Float32Array(size); this.g=new Float32Array(size); this.b=new Float32Array(size); this.r0=new Float32Array(size); this.g0=new Float32Array(size); this.b0=new Float32Array(size); this.tmp=new Float32Array(size); this.p=new Float32Array(size); this.div=new Float32Array(size); }
    IX(x,y){ return x + (this.n+2)*y; }
    setBnd(b,x){ const N=this.n; for(let i=1;i<=N;i++){ x[this.IX(0,i)]   = this.wrap? x[this.IX(N,i)]   : (b===1? -x[this.IX(1,i)]  : x[this.IX(1,i)]); x[this.IX(N+1,i)] = this.wrap? x[this.IX(1,i)]   : (b===1? -x[this.IX(N,i)]  : x[this.IX(N,i)]); x[this.IX(i,0)]   = this.wrap? x[this.IX(i,N)]   : (b===2? -x[this.IX(i,1)]  : x[this.IX(i,1)]); x[this.IX(i,N+1)] = this.wrap? x[this.IX(i,1)]   : (b===2? -x[this.IX(i,N)]  : x[this.IX(i,N)]); } x[this.IX(0,0)] = 0.5*(x[this.IX(1,0)] + x[this.IX(0,1)]); x[this.IX(0,N+1)] = 0.5*(x[this.IX(1,N+1)] + x[this.IX(0,N)]); x[this.IX(N+1,0)] = 0.5*(x[this.IX(N,0)] + x[this.IX(N+1,1)]); x[this.IX(N+1,N+1)] = 0.5*(x[this.IX(N,N+1)] + x[this.IX(N+1,N)]); }
    linSolve(b,x,x0,a,c){ const N=this.n, cR=1/c; for(let k=0;k<20;k++){ for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ x[this.IX(i,j)] = (x0[this.IX(i,j)] + a*( x[this.IX(i-1,j)] + x[this.IX(i+1,j)] + x[this.IX(i,j-1)] + x[this.IX(i,j+1)] ))*cR; } } this.setBnd(b,x); } }
    diffuse(b,x,x0,diff,dt){ const N=this.n; const a=dt*diff*N*N; this.linSolve(b,x,x0,a,1+4*a); }
    advect(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N; for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5)x+=N; while(x>N+0.5)x-=N; while(y<0.5)y+=N; while(y>N+0.5)y-=N; } else { if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; d[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]); } } this.setBnd(b,d); }
    advectMacCormack(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N, phiHat=this.tmp; // forward
      for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5)x+=N; while(x>N+0.5)x-=N; while(y<0.5)y+=N; while(y>N+0.5)y-=N; } else { if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; phiHat[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]); } } this.setBnd(b,phiHat); // backward
      for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i+dt0*u[this.IX(i,j)], y=j+dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5)x+=N; while(x>N+0.5)x-=N; while(y<0.5)y+=N; while(y>N+0.5)y-=N; } else { if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; const phiBar = s0*(t0*phiHat[this.IX(i0,j0)] + t1*phiHat[this.IX(i0,j1)]) + s1*(t0*phiHat[this.IX(i1,j0)] + t1*phiHat[this.IX(i1,j1)]); let corr = 0.5*(d0[this.IX(i,j)] - phiBar); d[this.IX(i,j)] = clamp(phiHat[this.IX(i,j)] + corr, Math.min(d0[this.IX(i,j)], phiHat[this.IX(i,j)]), Math.max(d0[this.IX(i,j)], phiHat[this.IX(i,j)])); } } this.setBnd(b,d); }
    project(u,v,p,div){ const N=this.n, IX=this.IX.bind(this); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ div[IX(i,j)] = -0.5*( u[IX(i+1,j)]-u[IX(i-1,j)] + v[IX(i,j+1)]-v[IX(i,j-1)] )/N; p[IX(i,j)] = 0; } } this.setBnd(0,div); this.setBnd(0,p); this.linSolve(0,p,div,1,4); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)]-p[IX(i-1,j)]); v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)]-p[IX(i,j-1)]); } } this.setBnd(1,u); this.setBnd(2,v); }
    vorticityConfinement(u,v,eps){ const N=this.n, IX=this.IX.bind(this); for(let i=2;i<=N-1;i++){ for(let j=2;j<=N-1;j++){ const dw_dx = Math.abs(v[IX(i+1,j)] - v[IX(i-1,j)])*0.5; const dw_dy = Math.abs(u[IX(i,j+1)] - u[IX(i,j-1)])*0.5; const len = Math.sqrt(dw_dx*dw_dx + dw_dy*dw_dy) + 1e-6; const Nx = dw_dx/len, Ny = dw_dy/len; const w = (v[IX(i+1,j)] - v[IX(i-1,j)] - (u[IX(i,j+1)] - u[IX(i,j-1)]))*0.5; this.u[IX(i,j)] += eps * (Ny * w); this.v[IX(i,j)] += eps * (-Nx * w); } } this.setBnd(1,this.u); this.setBnd(2,this.v); }
    step(){ const N=this.n, dt=this.dt; const u=this.u,v=this.v,u0=this.u0,v0=this.v0, r=this.r,g=this.g,b=this.b, r0=this.r0,g0=this.g0,b0=this.b0; if(this.gravY!==0){ for(let i=0;i<u.length;i++) v[i]+=this.gravY*dt/N; } if(this.buoy>0){ for(let i=0;i<r.length;i++){ const density=(r[i]+g[i]+b[i])*(1/3); v[i]+= -this.buoy*density*dt; } } this.diffuse(1,u0,u,this.visc,dt); this.diffuse(2,v0,v,this.visc,dt); this.project(u0,v0,this.p,this.div); if(this.advectMac){ this.advectMacCormack(1,u,u0,u0,v0,dt); this.advectMacCormack(2,v,v0,u0,v0,dt); } else { this.advect(1,u,u0,u0,v0,dt); this.advect(2,v,v0,u0,v0,dt); } this.project(u,v,this.p,this.div); if(this.confine && this.vort>0){ this.vorticityConfinement(u,v,this.vort*dt*0.0015); } this.diffuse(0,r0,r,this.diff,dt); this.diffuse(0,g0,g,this.diff,dt); this.diffuse(0,b0,b,this.diff,dt); if(this.advectMac){ this.advectMacCormack(0,r,r0,u,v,dt); this.advectMacCormack(0,g,g0,u,v,dt); this.advectMacCormack(0,b,b0,u,v,dt); } else { this.advect(0,r,r0,u,v,dt); this.advect(0,g,g0,u,v,dt); this.advect(0,b,b0,u,v,dt); } const decay = this.pretty? 0.9995 : 1.0; if(decay!==1) for(let i=0;i<r.length;i++){ r[i]*=decay; g[i]*=decay; b[i]*=decay; } u0.fill(0); v0.fill(0); r0.fill(0); g0.fill(0); b0.fill(0); }
  }

  // Allocate sim (match UI)
  let fluid = new Fluid(parseInt(ui.res.value,10));

  // Rebuild on res
  function rebuild(N){ fluid = new Fluid(N, ui.wrap.checked); lastStamp = performance.now(); }

  // Rendering (sample grid -> canvas)
  function draw(){ const N=fluid.n; const img=W.getImageData(0,0,C.width,C.height); const data=img.data; const cw=C.width, ch=C.height; for(let y=0;y<ch;y++){ const gy=1 + Math.floor((y/ch)*N); for(let x=0;x<cw;x++){ const gx=1 + Math.floor((x/cw)*N); const idx = fluid.IX(gx,gy); const r=fluid.r[idx], g=fluid.g[idx], b=fluid.b[idx]; const off=(y*cw+x)*4; data[off]=Math.max(0,Math.min(255, r*255)); data[off+1]=Math.max(0,Math.min(255, g*255)); data[off+2]=Math.max(0,Math.min(255, b*255)); data[off+3]=255; } } W.putImageData(img,0,0); }

  // Input (touch + pointer)
  let dragging=false, lastX=0, lastY=0, lastTime=0;
  function canvasPos(e){ const rect=C.getBoundingClientRect(); const t=e.touches? e.touches[0]: e; const x=(t.clientX-rect.left)/rect.width; const y=(t.clientY-rect.top)/rect.height; return {x:Math.min(0.999,Math.max(0.001,x)), y:Math.min(0.999,Math.max(0.001,y))}; }
  function addBrush(x,y,vx,vy){ const N=fluid.n; const bs=parseInt(ui.brush.value,10)|0; const f=parseFloat(ui.force.value); const i=1+Math.floor(x*N), j=1+Math.floor(y*N); for(let dy=-bs; dy<=bs; dy++){ for(let dx=-bs; dx<=bs; dx++){ if(dx*dx+dy*dy>bs*bs) continue; const ii=Math.min(N,Math.max(1,i+dx)); const jj=Math.min(N,Math.max(1,j+dy)); const idx=fluid.IX(ii,jj); fluid.u0[idx] += vx * f * 0.0005; fluid.v0[idx] += vy * f * 0.0005; const H=(performance.now()/30 + (ii+jj)*2)%360; const c=hsl(H,0.75,0.5); fluid.r0[idx] += c[0]*1.0; fluid.g0[idx] += c[1]*1.0; fluid.b0[idx] += c[2]*1.0; } } }

  C.addEventListener('touchstart', e=>{ e.preventDefault(); dragging=true; const p=canvasPos(e); lastX=p.x; lastY=p.y; lastTime=performance.now(); addBrush(p.x,p.y,0,0); }, {passive:false});
  C.addEventListener('touchmove', e=>{ e.preventDefault(); if(!dragging) return; const p=canvasPos(e); const now=performance.now(); const dt=(now-lastTime+1e-6); const vx=(p.x-lastX)/dt*16; const vy=(p.y-lastY)/dt*16; addBrush(p.x,p.y,vx,vy); lastX=p.x; lastY=p.y; lastTime=now; }, {passive:false});
  C.addEventListener('touchend', ()=>{ dragging=false; }, {passive:false});
  C.addEventListener('pointerdown', e=>{ if(e.pointerType==='mouse'){ dragging=true; const p=canvasPos(e); lastX=p.x; lastY=p.y; lastTime=performance.now(); addBrush(p.x,p.y,0,0);} });
  C.addEventListener('pointermove', e=>{ if(!dragging||e.pointerType!=='mouse') return; const p=canvasPos(e); const now=performance.now(); const dt=(now-lastTime+1e-6); const vx=(p.x-lastX)/dt*16; const vy=(p.y-lastY)/dt*16; addBrush(p.x,p.y,vx,vy); lastX=p.x; lastY=p.y; lastTime=now; });
  window.addEventListener('pointerup', ()=>{ dragging=false; });

  // Controls
  ui.res.addEventListener('change', ()=> rebuild(parseInt(ui.res.value,10)) );
  ui.clear.addEventListener('click', ()=>{ fluid.u.fill(0); fluid.v.fill(0); fluid.r.fill(0); fluid.g.fill(0); fluid.b.fill(0); });
  let paused=false; ui.pause.addEventListener('click', ()=>{ paused=!paused; ui.pause.textContent = paused? 'Resume â–¶':'Pause â–Œâ–Œ'; });
  ui.wrap.addEventListener('change', ()=>{ fluid.wrap = ui.wrap.checked; });
  on('.chip','click', el=>{ const p=el.dataset.preset; if(p==='calm'){ ui.vort.value=20; ui.visc.value=0.0006; ui.diff.value=0.0002; ui.grav.value=40; ui.buoy.value=0.1; ui.force.value=400; ui.brush.value=22; }
    if(p==='storm'){ ui.vort.value=70; ui.visc.value=0.0001; ui.diff.value=0.00005; ui.grav.value=180; ui.buoy.value=0.2; ui.force.value=1200; ui.brush.value=28; }
    if(p==='smoke'){ ui.vort.value=55; ui.visc.value=0.00015; ui.diff.value=0.0003; ui.grav.value=-40; ui.buoy.value=0.5; ui.force.value=800; ui.brush.value=24; }
    if(p==='nebula'){ ui.vort.value=35; ui.visc.value=0.00005; ui.diff.value=0.00025; ui.grav.value=0; ui.buoy.value=0.05; ui.force.value=600; ui.brush.value=26; ui.wrap.checked=true; fluid.wrap=true; }
    if(p==='ink'){ ui.vort.value=15; ui.visc.value=0.0008; ui.diff.value=0.0008; ui.grav.value=220; ui.buoy.value=0.05; ui.force.value=350; ui.brush.value=18; }
    if(p==='psy'){ ui.vort.value=80; ui.visc.value=0.00005; ui.diff.value=0.00005; ui.grav.value=110; ui.buoy.value=0.3; ui.force.value=1000; ui.brush.value=32; ui.pretty.checked=true; }
  });

  // Diagnostics
  function runDiagnostics(){ const results=[]; function ok(name,cond){ results.push([name, !!cond]); if(!cond) console.error('Test failed:', name); }
    ok('IX monotonic', ( ()=>{ const N=8, f=new Fluid(N); return f.IX(2,3) < f.IX(3,3) && f.IX(1,1) < f.IX(1,2); })() );
    ok('Advect zero-vel stable', ( ()=>{ const f=new Fluid(8); for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) f.r0[f.IX(i,j)] = i+j; f.advect(0,f.r,f.r0,f.u,f.v,0.016); return Math.abs(f.r[f.IX(4,4)] - f.r0[f.IX(4,4)]) < 1e-3; })() );
    ok('Projection reduces div', ( ()=>{ const f=new Fluid(8); for(let j=1;j<=8;j++) for(let i=1;i<=8;i++){ f.u[f.IX(i,j)]=(i%3)-1; f.v[f.IX(i,j)]=(j%2)-0.5; } let before=0, after=0; for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) before += Math.abs( (f.u[f.IX(i+1,j)]-f.u[f.IX(i-1,j)] + f.v[f.IX(i,j+1)]-f.v[f.IX(i,j-1)])/(2*8) ); f.project(f.u,f.v,f.p,f.div); for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) after += Math.abs( (f.u[f.IX(i+1,j)]-f.u[f.IX(i-1,j)] + f.v[f.IX(i,j+1)]-f.v[f.IX(i,j-1)])/(2*8) ); return after < before; })() );
    ok('Step finite', ( ()=>{ const f=new Fluid(16); f.r.fill(0.1); f.g.fill(0.2); f.b.fill(0.3); f.step(); for(let k=0;k<f.r.length;k++) if(!isFinite(f.r[k]+f.g[k]+f.b[k])) return false; return true; })() );
    // Added tests
    ok('MacCormack == Semi-Lag for zero velocity', ( ()=>{ const f=new Fluid(8); // initial pattern
      for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) f.r0[f.IX(i,j)] = Math.sin(i)+Math.cos(j);
      f.advect(0,f.r,f.r0,f.u,f.v,0.02); const outSL = f.r.slice();
      f.r.fill(0); f.advectMacCormack(0,f.r,f.r0,f.u,f.v,0.02);
      let err=0; for(let k=0;k<f.r.length;k++) err = Math.max(err, Math.abs(f.r[k]-outSL[k]));
      return err < 1e-6; })() );
    ok('Wrap edges copy', ( ()=>{ const f=new Fluid(8,true); f.r.fill(0); f.r[f.IX(1,4)]=1; f.setBnd(0,f.r); return f.r[f.IX(0,4)]===f.r[f.IX(8,4)]; })() );

    const passed = results.every(r=>r[1]); const cls = passed?'ok':'err'; statusEl.textContent = passed? 'Diagnostics: PASS' : 'Diagnostics: FAIL'; statusEl.className = 'status '+cls; console.table(results.map(([name,ok])=>({test:name, ok}))); return passed; }
  ui.diag.addEventListener('click', runDiagnostics);

  // Main loop
  let lastStamp=performance.now(), fpsCount=0;
  function tick(now){ requestAnimationFrame(tick);
    // Apply UI -> solver params
    fluid.dt = Math.min(0.05, parseFloat(ui.dt.value));
    fluid.visc = parseFloat(ui.visc.value);
    fluid.diff = parseFloat(ui.diff.value);
    fluid.vort = parseFloat(ui.vort.value);
    fluid.gravY = parseFloat(ui.grav.value)/1000; // scaled
    fluid.buoy = parseFloat(ui.buoy.value);
    fluid.advectMac = ui.macc.checked;
    fluid.wrap = ui.wrap.checked;
    fluid.pretty = ui.pretty.checked;

    if(!paused){ fluid.step(); draw(); }
    fpsCount++; if(now-lastStamp>250){ const fps=(fpsCount*1000/(now-lastStamp))|0; fpsEl.textContent = `${fps} fps`; fpsCount=0; lastStamp=now; }
  }
  requestAnimationFrame(tick);

  // Error surfacing
  window.addEventListener('error', (e)=>{ statusEl.textContent = 'Error: '+(e.message||'unknown'); statusEl.className='status err'; });
})();
</script>
</body>
</html>
