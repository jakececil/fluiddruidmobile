<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fluid Dynamics Visualizer ‚Äî Mobile/Desktop</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#11161f; --ink:#cde6ff; --accent:#8b5cf6; --accent2:#22d3ee;
      --muted:#7e8aa2; --peek:56px; /* height of visible grab area on mobile */
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 20% 0%, #121826, #0b0f14 40% 100%);color:var(--ink);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif; overscroll-behavior:none}
    *{box-sizing:border-box}

    /* Desktop: left menu, right playfield */
    #wrap{display:grid;grid-template-columns: 340px 1fr; grid-template-rows: 100vh; gap:0}
    #ui{background:linear-gradient(180deg,rgba(17,22,31,.95),rgba(17,22,31,.85));backdrop-filter: blur(8px);
         border-right:1px solid rgba(255,255,255,.06); padding:16px 14px 18px 16px; overflow:auto}
    #title{font-weight:800; letter-spacing:.5px; font-size:18px; margin:6px 0 12px}
    .sub{color:var(--muted); font-size:12px; margin-top:-6px; margin-bottom:12px}
    .row{margin:10px 0 14px}
    .row label{display:flex; align-items:center; justify-content:space-between; gap:10px; font-size:13px; color:#c7d3ea}
    .row input[type="range"]{width:100%}
    .row input[type="color"]{width:100%; height:36px; border:none; background:#0000}
    .row .val{font-variant-numeric:tabular-nums; color:#a9b7d9; min-width:70px; text-align:right}
    .grid{display:grid; grid-template-columns: 1fr 1fr; gap:8px}
    .toggle{display:flex; align-items:center; gap:8px; cursor:pointer; user-select:none; font-size:13px}
    .toggle input{appearance:none; width:36px; height:22px; background:#2b3344; border-radius:999px; position:relative; outline:none; transition:.2s}
    .toggle input:checked{background:linear-gradient(90deg, var(--accent), var(--accent2))}
    .toggle input::after{content:""; position:absolute; top:3px; left:3px; width:16px; height:16px; background:#fff; border-radius:50%; transition:.2s}
    .toggle input:checked::after{left:17px}
    button{background:#1b2333; color:#cde6ff; border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px 12px; font-weight:700; cursor:pointer}
    button:hover{border-color:rgba(255,255,255,.2); box-shadow:0 0 0 2px rgba(114,34,255,.15)}

    #canvasWrap{position:relative; height:100vh; overflow:hidden; z-index:1}
    canvas{display:block; width:100%; height:100%; touch-action:none}
    #hud{position:absolute; top:10px; left:10px; font-size:12px; color:#b9c6e4; background:rgba(10,14,22,.4); padding:6px 8px; border-radius:8px; border:1px solid rgba(255,255,255,.08); z-index:2}
    #footer{font-size:11px; color:#8aa0c8; margin-top:10px;}
    .row .group{display:flex; gap:8px}
    .row .group > *{flex:1}
    .preset{display:flex; flex-wrap:wrap; gap:8px; margin-top:6px}
    .preset button{padding:8px 10px; font-size:12px}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace; background:#0e1421; border:1px solid rgba(255,255,255,.08); padding:2px 6px; border-radius:6px}

    /* Mobile: top playfield, bottom sheet that peeks and is draggable. */
    #sheetHandle{position:sticky; top:0; display:flex; justify-content:center; align-items:center; padding:8px 0 10px; margin:-8px -6px 8px; background:linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,0)); z-index:2}
    #sheetHandle .bar{width:48px; height:5px; border-radius:999px; background:rgba(200,220,255,.35);}

    @media (max-width: 900px), (hover: none) and (pointer: coarse) {
      :root{ --peek:64px; }
      #wrap{grid-template-columns: 1fr; grid-template-rows: 1fr auto; height:100svh;}
      #canvasWrap{height:auto; min-height: 65svh}
      /* bottom sheet sits above canvas, always visible by --peek */
      #ui{position:fixed; left:0; right:0; bottom:0; max-height:70svh; border-right:none; border-top:1px solid rgba(255,255,255,.08); border-radius:16px 16px 0 0;
           padding:14px 14px 20px; overflow:auto; transform:translateY(calc(100% - var(--peek))); transition:transform .25s ease; z-index:1001; background:linear-gradient(180deg,rgba(17,22,31,.95),rgba(17,22,31,.88));
           touch-action:pan-y}
      body.menu-open #ui{ transform:translateY(0); }
      /* canvas locks page scroll; only the sheet scrolls when open */
      body:not(.menu-open) #ui{ pointer-events:none; }
      body.menu-open{ overscroll-behavior:contain; }
    }
  </style>
</head>
<body class="">
  <div id="wrap">
    <div id="canvasWrap">
      <canvas id="c"></canvas>
      <div id="hud">FPS: <span id="fps">0</span> | Dye: RGB | Advection: <span id="adv">MacCormack</span></div>
    </div>

    <div id="ui" role="region" aria-label="Controls">
      <div id="sheetHandle" aria-label="Drag to open/close"><div class="bar"></div></div>
      <div id="title">üåà Fluid Dynamics Visualizer</div>
      <div class="sub">Tap/drag to paint dye & add force. Long-press or right-click (or ‚å•/Alt) to add suction. Hold <span class="kbd">Shift</span> for big brush.</div>

      <div class="row">
        <label>Resolution <span class="val"><span id="nDisplay"></span> √ó <span id="nDisplayY"></span></span></label>
        <input id="n" type="range" min="48" max="220" step="4" value="144">
      </div>

      <div class="row grid">
        <div>
          <label>Viscosity <span class="val" id="viscVal">0.0002</span></label>
          <input id="visc" type="range" min="0" max="0.01" step="0.0001" value="0.0002">
        </div>
        <div>
          <label>Diffusion <span class="val" id="diffVal">0.0001</span></label>
          <input id="diff" type="range" min="0" max="0.01" step="0.0001" value="0.0001">
        </div>
      </div>

      <div class="row grid">
        <div>
          <label>Time Step <span class="val" id="dtVal">0.016</span></label>
          <input id="dt" type="range" min="0.006" max="0.033" step="0.001" value="0.016">
        </div>
        <div>
          <label>Vorticity <span class="val" id="vortVal">18</span></label>
          <input id="vort" type="range" min="0" max="40" step="1" value="18">
        </div>
      </div>

      <div class="row grid">
        <div>
          <label>Brush Size <span class="val" id="brushVal">14</span></label>
          <input id="brush" type="range" min="1" max="100" step="1" value="14">
        </div>
        <div>
          <label>Force <span class="val" id="forceVal">900</span></label>
          <input id="force" type="range" min="10" max="2200" step="10" value="900">
        </div>
      </div>

      <div class="row grid">
        <div>
          <label>Gravity Y <span class="val" id="gyVal">0</span></label>
          <input id="gy" type="range" min="-200" max="200" step="1" value="0">
        </div>
        <div>
          <label>Smoke Buoyancy <span class="val" id="buoyVal">0.10</span></label>
          <input id="buoy" type="range" min="0" max="1" step="0.01" value="0.10">
        </div>
      </div>

      <div class="row">
        <label>Ink Color</label>
        <div class="group">
          <input id="ink" type="color" value="#66ccff">
          <button id="rainbow">Cycle üé†</button>
        </div>
      </div>

      <div class="row grid">
        <div class="toggle"><input id="confToggle" type="checkbox" checked><span>Vorticity Confinement</span></div>
        <div class="toggle"><input id="advectMAC" type="checkbox" checked><span>MacCormack Advection</span></div>
      </div>

      <div class="row grid">
        <div class="toggle"><input id="edges" type="checkbox"><span>Wrap Edges</span></div>
        <div class="toggle"><input id="pretty" type="checkbox" checked><span>Pretty Additives ‚ú®</span></div>
      </div>

      <div class="row">
        <label>Color Cycle Speed <span class="val" id="colorSpeedVal">360</span></label>
        <input id="colorSpeed" type="range" min="0" max="1440" step="10" value="360">
      </div>

      <div class="row">
        <label>Presets</label>
        <div class="preset">
          <button data-preset="calm">Calm Pool</button>
          <button data-preset="storm">Stormy</button>
          <button data-preset="smoke">Smoky Room</button>
          <button data-preset="nebula">Nebula</button>
          <button data-preset="inkdrop">Ink Drop</button>
          <button data-preset="psyche">Psychedelia üå™Ô∏è</button>
        </div>
      </div>

      <div class="row grid">
        <button id="clear">Clear</button>
        <button id="pause">Pause ‚ñå‚ñå</button>
      </div>

      <div id="footer">
        WASD / ‚Üê‚Üë‚Üí‚Üì swirl; Shift = big brush; Alt/Right-click = suction. <br>
        Algorithm: Stable Fluids w/ MacCormack, vorticity confinement, buoyancy.
      </div>
    </div>
  </div>

  <script>
    // ============================
    // Utility helpers
    // ============================
    const clamp=(x,a,b)=>x<a?a:(x>b?b:x);

    // Fast color cycle
    let hue=200; let hueVel=360;

    // ============================
    // Fluid grid
    // ============================
    class Fluid {
      constructor(n, wrap=false){ this.setResolution(n, wrap); this.diff=1e-4; this.visc=2e-4; this.dt=0.016; this.vort=18; this.confine=true; this.buoy=0.1; this.advectMac=true; this.gravY=0; this.pretty=true; }
      setResolution(n, wrap){ this.n=n|0; this.wrap=!!wrap; const N=this.n, size=(N+2)*(N+2); this.u=new Float32Array(size); this.v=new Float32Array(size); this.u0=new Float32Array(size); this.v0=new Float32Array(size); this.r=new Float32Array(size); this.g=new Float32Array(size); this.b=new Float32Array(size); this.r0=new Float32Array(size); this.g0=new Float32Array(size); this.b0=new Float32Array(size); this.tmp=new Float32Array(size); }
      IX(x,y){ return x + (this.n+2)*y; }
      addSource(x,s,dt){ for(let i=0;i<x.length;i++) x[i]+=dt*s[i]; }
      setBnd(b,x){ const N=this.n; for(let i=1;i<=N;i++){ x[this.IX(0,i)] = this.wrap? x[this.IX(N,i)] : (b===1? -x[this.IX(1,i)] : x[this.IX(1,i)]); x[this.IX(N+1,i)] = this.wrap? x[this.IX(1,i)] : (b===1? -x[this.IX(N,i)] : x[this.IX(N,i)]); x[this.IX(i,0)] = this.wrap? x[this.IX(i,N)] : (b===2? -x[this.IX(i,1)] : x[this.IX(i,1)]); x[this.IX(i,N+1)] = this.wrap? x[this.IX(i,1)] : (b===2? -x[this.IX(i,N)] : x[this.IX(i,N)]); } x[this.IX(0,0)] = 0.5*(x[this.IX(1,0)] + x[this.IX(0,1)]); x[this.IX(0,N+1)] = 0.5*(x[this.IX(1,N+1)] + x[this.IX(0,N)]); x[this.IX(N+1,0)] = 0.5*(x[this.IX(N,0)] + x[this.IX(N+1,1)]); x[this.IX(N+1,N+1)] = 0.5*(x[this.IX(N,N+1)] + x[this.IX(N+1,N)]); }
      linSolve(b,x,x0,a,c){ const N=this.n; const cr=1.0/c; for(let k=0;k<20;k++){ for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ x[this.IX(i,j)] = (x0[this.IX(i,j)] + a*( x[this.IX(i-1,j)] + x[this.IX(i+1,j)] + x[this.IX(i,j-1)] + x[this.IX(i,j+1)] ))*cr; } } this.setBnd(b,x);} }
      diffuse(b,x,x0,diff,dt){ const a=dt*diff*this.n*this.n; this.linSolve(b,x,x0,a,1+4*a); }
      advect(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N; for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; } else { if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5; if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; d[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]); } } this.setBnd(b,d); }
      advectMacCormack(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N, phiHat=this.tmp; for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; } else { if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5; if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; phiHat[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);} } this.setBnd(b,phiHat); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ let x=i+dt0*u[this.IX(i,j)], y=j+dt0*v[this.IX(i,j)]; if(this.wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; } else { if(x<0.5) x=0.5; if(x>N+0.5) x=N+0.5; if(y<0.5) y=0.5; if(y>N+0.5) y=N+0.5; } const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1; const s1=x-i0, s0=1-s1, t1=y-j0, t0=1-t1; const phiBar = s0*(t0*phiHat[this.IX(i0,j0)] + t1*phiHat[this.IX(i0,j1)]) + s1*(t0*phiHat[this.IX(i1,j0)] + t1*phiHat[this.IX(i1,j1)]); let corr=0.5*(d0[this.IX(i,j)]-phiBar); const lo=Math.min(d0[this.IX(i,j)], phiHat[this.IX(i,j)]), hi=Math.max(d0[this.IX(i,j)], phiHat[this.IX(i,j)]); d[this.IX(i,j)] = Math.max(lo, Math.min(hi, phiHat[this.IX(i,j)] + corr)); } } this.setBnd(b,d); }
      project(u,v,p,div){ const N=this.n, IX=this.IX.bind(this); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ div[IX(i,j)] = -0.5*( u[IX(i+1,j)]-u[IX(i-1,j)] + v[IX(i,j+1)]-v[IX(i,j-1)] )/N; p[IX(i,j)]=0; } } this.setBnd(0,div); this.setBnd(0,p); this.linSolve(0,p,div,1,4); for(let i=1;i<=N;i++){ for(let j=1;j<=N;j++){ u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)]-p[IX(i-1,j)]); v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)]-p[IX(i,j-1)]); } } this.setBnd(1,u); this.setBnd(2,v); }
      vorticityConfinement(u,v,eps){ const N=this.n, IX=this.IX.bind(this); for(let i=2;i<=N-1;i++){ for(let j=2;j<=N-1;j++){ const dw_dx=(Math.abs(v[IX(i+1,j)]-v[IX(i-1,j)])*0.5), dw_dy=(Math.abs(u[IX(i,j+1)]-u[IX(i,j-1)])*0.5); const len=Math.sqrt(dw_dx*dw_dx+dw_dy*dw_dy)+1e-6; const Nx=dw_dx/len, Ny=dw_dy/len; const w=(v[IX(i+1,j)]-v[IX(i-1,j)]-(u[IX(i,j+1)]-u[IX(i,j-1)]))*0.5; this.u[IX(i,j)] += eps*(Ny*w); this.v[IX(i,j)] += eps*(-Nx*w); } } this.setBnd(1,this.u); this.setBnd(2,this.v); }
      step(){ const dt=this.dt, u=this.u,v=this.v,u0=this.u0,v0=this.v0, r=this.r,g=this.g,b=this.b, r0=this.r0,g0=this.g0,b0=this.b0; if(this.gravY!==0){ for(let i=0;i<u.length;i++) v[i]+=this.gravY*dt/this.n; } if(this.buoy>0){ for(let i=0;i<r.length;i++){ const d=(r[i]+g[i]+b[i])*(1/3); v[i]+=-this.buoy*d*dt; } } this.diffuse(1,u0,u,this.visc,dt); this.diffuse(2,v0,v,this.visc,dt); this.project(u0,v0,u,v); if(this.advectMac){ this.advectMacCormack(1,u,u0,u0,v0,dt); this.advectMacCormack(2,v,v0,u0,v0,dt); } else { this.advect(1,u,u0,u0,v0,dt); this.advect(2,v,v0,u0,v0,dt); } this.project(u,v,u0,v0); if(this.confine && this.vort>0){ this.vorticityConfinement(u,v,this.vort*dt*0.0015); } this.diffuse(0,r0,r,this.diff,dt); this.diffuse(0,g0,g,this.diff,dt); this.diffuse(0,b0,b,this.diff,dt); if(this.advectMac){ this.advectMacCormack(0,r,r0,u,v,dt); this.advectMacCormack(0,g,g0,u,v,dt); this.advectMacCormack(0,b,b0,u,v,dt); } else { this.advect(0,r,r0,u,v,dt); this.advect(0,g,g0,u,v,dt); this.advect(0,b,b0,u,v,dt); } const decay=0.9995; for(let i=0;i<r.length;i++){ r[i]*=decay; g[i]*=decay; b[i]*=decay; } u0.fill(0); v0.fill(0); r0.fill(0); g0.fill(0); b0.fill(0); }
    }

    // ============================
    // Rendering
    // ============================
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    function resizeCanvas(){ const dpr=Math.min(2, window.devicePixelRatio||1); canvas.width = Math.floor(canvas.clientWidth * dpr); canvas.height = Math.floor(canvas.clientHeight * dpr); }
    function rgb(r,g,b){ return `rgb(${(r*255)|0},${(g*255)|0},${(b*255)|0})`; }

    // ============================
    // App + UI wiring
    // ============================
    const fluid = new Fluid(144);
    const el = id=>document.getElementById(id);
    const n = el('n'), visc=el('visc'), diff=el('diff'), dt=el('dt'), vort=el('vort');
    const brush=el('brush'), force=el('force'), gy=el('gy'), buoy=el('buoy');
    const ink=el('ink'); const confToggle=el('confToggle'); const advectMAC=el('advectMAC'); const edges=el('edges'); const pretty=el('pretty');
    const clearBtn=el('clear'); const pauseBtn=el('pause'); const rainbow=el('rainbow');
    const colorSpeed=el('colorSpeed'); const colorSpeedVal=el('colorSpeedVal');
    const nDisplay=el('nDisplay'), nDisplayY=el('nDisplayY'); const viscVal=el('viscVal'), diffVal=el('diffVal'), dtVal=el('dtVal'), vortVal=el('vortVal');
    const brushVal=el('brushVal'), forceVal=el('forceVal'), gyVal=el('gyVal'), buoyVal=el('buoyVal');
    const fpsEl=el('fps'); const advEl=el('adv');

    function syncLabels(){ nDisplay.textContent=fluid.n; nDisplayY.textContent=fluid.n; viscVal.textContent=(+visc.value).toFixed(4); diffVal.textContent=(+diff.value).toFixed(4); dtVal.textContent=(+dt.value).toFixed(3); vortVal.textContent=(+vort.value).toString(); brushVal.textContent=brush.value; forceVal.textContent=force.value; gyVal.textContent=gy.value; buoyVal.textContent=(+buoy.value).toFixed(2); advEl.textContent=advectMAC.checked? 'MacCormack':'Semi-Lagrangian'; colorSpeedVal.textContent=(+colorSpeed.value).toString(); }
    function applyUI(){ fluid.visc=+visc.value; fluid.diff=+diff.value; fluid.dt=+dt.value; fluid.vort=+vort.value; fluid.confine=confToggle.checked; fluid.advectMac=advectMAC.checked; fluid.wrap=edges.checked; fluid.buoy=+buoy.value; fluid.gravY=+gy.value/1000; hueVel=+colorSpeed.value; syncLabels(); }
    [visc,diff,dt,vort,brush,force,gy,buoy,confToggle,advectMAC,edges,pretty,colorSpeed].forEach(x=>x.addEventListener('input', applyUI));
    n.addEventListener('change', ()=>{ fluid.setResolution(+n.value, edges.checked); syncLabels(); });
    clearBtn.addEventListener('click', ()=>{ fluid.u.fill(0); fluid.v.fill(0); fluid.r.fill(0); fluid.g.fill(0); fluid.b.fill(0); });
    let paused=false; pauseBtn.addEventListener('click', ()=>{ paused=!paused; pauseBtn.textContent = paused? 'Resume ‚ñ∂':'Pause ‚ñå‚ñå'; });
    rainbow.addEventListener('click', ()=>{ const sign = Math.random()<.5?-1:1; hueVel=(Math.random()*720+240)*sign; colorSpeed.value=Math.abs(hueVel); syncLabels(); });

    // ============================
    // Interaction
    // Canvas should only draw; the sheet handles all dragging/scrolling
    // ============================
    const mouse={x:0,y:0, px:0,py:0, down:false, alt:false};
    const canvasEl=document.getElementById('c');
    canvasEl.addEventListener('contextmenu',e=>e.preventDefault());

    function updateFromClient(clientX, clientY){
      const rect=canvasEl.getBoundingClientRect();
      mouse.px=mouse.x; mouse.py=mouse.y;
      mouse.x = ((clientX - rect.left)/rect.width) * (fluid.n+2);
      mouse.y = ((clientY - rect.top)/rect.height) * (fluid.n+2);
    }

    // lock page gestures on canvas always
    ['touchstart','touchmove','touchend','gesturestart'].forEach(type=>{
      canvasEl.addEventListener(type, e=>{ e.preventDefault(); }, {passive:false});
    });

    // pointer path (works on iOS Safari 13+)
    canvasEl.addEventListener('pointerdown', e=>{
      mouse.down=true; mouse.alt = (e.button===2)||e.altKey;
      try{canvasEl.setPointerCapture(e.pointerId);}catch(_){ }
      updateFromClient(e.clientX ?? e.pageX, e.clientY ?? e.pageY);
      e.preventDefault();
      paint(e);
    }, {passive:false});
    canvasEl.addEventListener('pointermove', e=>{
      if(!mouse.down) return;
      updateFromClient(e.clientX ?? e.pageX, e.clientY ?? e.pageY);
      e.preventDefault();
      paint(e);
    }, {passive:false});
    canvasEl.addEventListener('pointerup', e=>{ mouse.down=false; try{canvasEl.releasePointerCapture(e.pointerId);}catch(_){ } });
    window.addEventListener('pointercancel', ()=>{ mouse.down=false; });

    // Touch fallback for odd engines (won't fire if pointer events exist)
    let touchFallbackArmed=true;
    window.addEventListener('pointerdown', ()=>{ touchFallbackArmed=false; }, {once:true});
    canvasEl.addEventListener('touchstart', e=>{
      if(!touchFallbackArmed) return; const t=e.touches[0]; if(!t) return;
      mouse.down=true; updateFromClient(t.clientX, t.clientY); e.preventDefault(); paint({pointerType:'touch'});
    }, {passive:false});
    canvasEl.addEventListener('touchmove', e=>{
      if(!touchFallbackArmed||!mouse.down) return; const t=e.touches[0]; if(!t) return;
      updateFromClient(t.clientX, t.clientY); e.preventDefault(); paint({pointerType:'touch'});
    }, {passive:false});
    canvasEl.addEventListener('touchend', ()=>{ if(!touchFallbackArmed) return; mouse.down=false; }, {passive:false});

    function paint(e){
      const N=fluid.n; const IX=fluid.IX.bind(fluid);
      const r=fluid.r0, g=fluid.g0, b=fluid.b0, u=fluid.u0, v=fluid.v0;
      const big = (e && (e.pointerType==='touch' || e.shiftKey))? 2.2 : 1.0;
      const bs = (+brush.value) * big;
      const dx = (mouse.x - mouse.px) * (+force.value)/500; const dy = (mouse.y - mouse.py) * (+force.value)/500;
      let inkColor = hexToRgb(ink.value);
      if(pretty.checked){ hue = (hue + hueVel*fluid.dt) % 360; const c = hsl2rgb(hue/360, 0.75, 0.55); inkColor = {r:c[0]*255, g:c[1]*255, b:c[2]*255}; }
      for(let i=-bs;i<=bs;i++){
        for(let j=-bs;j<=bs;j++){
          const x=(mouse.x|0)+i, y=(mouse.y|0)+j; if(x<1||y<1||x>N||y>N) continue;
          const w = 1 - Math.hypot(i,j)/bs; if(w<=0) continue; const idx = IX(x,y); const mul = mouse.alt? -0.6 : 1.0;
          u[idx] += dx * w * mul; v[idx] += dy * w * mul;
          r[idx] += (inkColor.r/255) * w * 1.1; g[idx] += (inkColor.g/255) * w * 1.1; b[idx] += (inkColor.b/255) * 1.1 * w;
        }
      }
    }

    function hexToRgb(hex){ const n=parseInt(hex.slice(1),16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; }
    function hsl2rgb(h,s,l){ const a=s*Math.min(l,1-l); const f=n=>{const k=(n+h*12)%12; return l-a*Math.max(-1,Math.min(k-3,9-k,1));}; return [f(0),f(8),f(4)]; }

    // ============================
    // Draw dye to canvas
    // ============================
    function render(){
      const N=fluid.n; const IX=fluid.IX.bind(fluid);
      const cw = canvasEl.width, ch = canvasEl.height; const cellX = cw/(N+2), cellY=ch/(N+2);
      ctx.clearRect(0,0,cw,ch);
      const r=fluid.r,g=fluid.g,b=fluid.b;
      for(let i=1;i<=N;i++){
        for(let j=1;j<=N;j++){
          const rr=r[IX(i,j)], gg=g[IX(i,j)], bb=b[IX(i,j)]; if(rr+gg+bb<1e-4) continue;
          ctx.fillStyle = rgb(rr,gg,bb); ctx.fillRect((i-0.5)*cellX, (j-0.5)*cellY, cellX+1, cellY+1);
        }
      }
    }

    // ============================
    // Main loop + FPS
    // ============================
    let last=performance.now(), frames=0, fps=0, fpsT=0;
    function loop(ts){
      const dtReal = (ts-last)/1000; last=ts; fpsT+=dtReal; frames++; if(fpsT>0.5){ fps = Math.round(frames/fpsT*2)/2; fpsEl.textContent=fps; frames=0; fpsT=0; }
      if(!paused){ fluid.addSource(fluid.u, fluid.u0, 1); fluid.addSource(fluid.v, fluid.v0, 1); fluid.addSource(fluid.r, fluid.r0, 1); fluid.addSource(fluid.g, fluid.g0, 1); fluid.addSource(fluid.b, fluid.b0, 1); fluid.step(); }
      render(); requestAnimationFrame(loop);
    }

    // Resize + start
    const ro = new ResizeObserver(resizeCanvas); ro.observe(document.getElementById('canvasWrap'));
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); applyUI(); syncLabels(); requestAnimationFrame(loop);

    // ============================
    // Bottom sheet drag logic (mobile)
    // ============================
    const sheet = document.getElementById('ui');
    const handle = document.getElementById('sheetHandle');
    let sheetStartY=0, sheetStartTranslate=0, dragging=false;

    function currentTranslate(){
      const st = getComputedStyle(sheet).transform;
      if(st && st!=='none'){
        const m = new DOMMatrix(st); return m.m42; // translateY
      }
      // derive from class
      const isOpen = document.body.classList.contains('menu-open');
      return isOpen ? 0 : sheet.offsetHeight - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--peek'));
    }

    function setTranslate(y){ sheet.style.transform = `translateY(${clamp(y, 0, sheet.offsetHeight - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--peek')))}px)`; }

    function openSheet(open){ document.body.classList.toggle('menu-open', open); sheet.style.transform = open? 'translateY(0)' : `translateY(calc(100% - var(--peek)))`; }

    const startDrag = (e)=>{
      const pY = (e.touches? e.touches[0].clientY : e.clientY);
      dragging=true; sheetStartY=pY; sheetStartTranslate=currentTranslate();
      // prevent canvas receiving this start
      e.preventDefault();
      handle.setPointerCapture?.(e.pointerId);
    };
    const moveDrag = (e)=>{
      if(!dragging) return; const pY = (e.touches? e.touches[0].clientY : e.clientY);
      const dy = pY - sheetStartY; setTranslate(sheetStartTranslate + dy);
      e.preventDefault();
    };
    const endDrag = (e)=>{
      if(!dragging) return; dragging=false; const pY = (e.changedTouches? e.changedTouches[0].clientY : e.clientY);
      const dy = pY - sheetStartY; const open = (sheetStartTranslate + dy) < (sheet.offsetHeight*0.55);
      openSheet(open);
      sheet.style.transition = 'transform .22s ease';
      setTimeout(()=>{ sheet.style.transition=''; }, 250);
      e.preventDefault();
    };

    // Handle drag area (works on touch and mouse)
    handle.addEventListener('pointerdown', startDrag, {passive:false});
    window.addEventListener('pointermove', moveDrag, {passive:false});
    window.addEventListener('pointerup', endDrag, {passive:false});
    handle.addEventListener('touchstart', startDrag, {passive:false});
    window.addEventListener('touchmove', moveDrag, {passive:false});
    window.addEventListener('touchend', endDrag, {passive:false});

    // Intro state: closed (peek visible) on mobile; open on desktop
    if (matchMedia('(max-width: 900px)').matches) {
      openSheet(false);
    } else {
      document.body.classList.add('menu-open');
    }

    // ============================
    // Intro burst
    // ============================
    (function intro(){
      const w=canvasEl.clientWidth, h=canvasEl.clientHeight; const cx=w*0.5, cy=h*0.5;
      const old = hueVel; hueVel = Math.max(360, hueVel); mouse.down=true; updateFromClient(cx, cy);
      for(let k=0;k<10;k++){ hue=(k*36)%360; paint({pointerType:'mouse'}); mouse.px=mouse.x; mouse.py=mouse.y; mouse.x+=Math.cos(k)*6; mouse.y+=Math.sin(k)*6; }
      mouse.down=false; hueVel = old;
    })();
  </script>
</body>
</html>
