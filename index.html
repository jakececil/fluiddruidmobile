<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fluid Dynamics â€” Mobile Safari</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#111827cc;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--accent2:#a78bfa;
      --card:#0e1622cc;--chip:#1f2937;--good:#10b981;--warn:#f59e0b;--danger:#ef4444;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased;}
    #app{position:fixed;inset:0;display:flex;flex-direction:column;}
    header{display:flex;align-items:center;gap:.6rem;padding:.7rem env(safe-area-inset-right) .7rem env(safe-area-inset-left);}
    header h1{font-size:1.05rem;margin:0;letter-spacing:.1px;font-weight:700}
    header .fps{margin-left:auto;font-variant-numeric:tabular-nums;opacity:.85}
    #canvasWrap{position:relative;flex:1;min-height:240px;}
    canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none;background:#070a0f;display:block;}

    /* Floating control button */
    #fab{position:fixed;right:env(safe-area-inset-right);bottom:calc(1rem + env(safe-area-inset-bottom));z-index:10}
    #fab button{background:linear-gradient(135deg,var(--accent),var(--accent2));color:white;border:none;border-radius:999px;padding:.9rem 1.05rem;box-shadow:0 10px 25px #0008;font-weight:700}

    /* Bottom sheet controls */
    #sheet{position:fixed;left:0;right:0;bottom:0;transform:translateY(100%);transition:.35s transform ease;z-index:20}
    #sheet.open{transform:translateY(0)}
    .sheet-contents{background:var(--panel);backdrop-filter:blur(10px);border-radius:16px 16px 0 0;box-shadow:0 -15px 40px #000c;padding:12px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left)}
    .drag{width:44px;height:4px;background:#ffffff35;border-radius:2px;margin:6px auto 10px}
    .row{display:flex;align-items:center;gap:.5rem;margin:8px 0}
    .row label{flex:0 0 44%;font-size:.86rem;color:var(--muted)}
    .row input[type=range]{flex:1}
    .switch{display:flex;align-items:center;gap:.5rem;margin:6px 0}
    .chips{display:flex;flex-wrap:wrap;gap:.4rem;margin-top:.25rem}
    .chip{background:var(--chip);border-radius:999px;padding:.45rem .65rem;font-size:.82rem;}
    .controls{max-height:56vh;overflow:auto;-webkit-overflow-scrolling:touch}
    .btns{display:flex;gap:.5rem;margin-top:8px}
    .btn{flex:1;background:#1f2937;border:1px solid #ffffff22;border-radius:10px;padding:.6rem .8rem;color:#fff;text-align:center}
    .btn.full{flex:unset;width:100%}
    .small{font-size:.8rem;color:var(--muted)}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>ðŸŒˆ Fluid Dynamics Visualizer</h1>
      <div class="fps" id="fps">-- fps</div>
    </header>
    <div id="canvasWrap">
      <canvas id="view" aria-label="Fluid simulation"></canvas>
    </div>
  </div>

  <div id="fab"><button id="toggle">Controls â–´</button></div>
  <div id="sheet" aria-live="polite" aria-expanded="false">
    <div class="sheet-contents" id="sheetC">
      <div class="drag"></div>
      <div class="controls" id="controls">
        <div class="row"><label>Resolution</label><input id="res" type="range" min="64" max="256" step="32" value="160"></div>
        <div class="row"><label>Time Step</label><input id="dt" type="range" min="0.004" max="0.033" step="0.001" value="0.016"></div>
        <div class="row"><label>Viscosity</label><input id="visc" type="range" min="0" max="0.003" step="0.0001" value="0.0002"></div>
        <div class="row"><label>Diffusion</label><input id="diff" type="range" min="0" max="0.003" step="0.0001" value="0.0002"></div>
        <div class="row"><label>Vorticity</label><input id="vort" type="range" min="0" max="80" step="1" value="45"></div>
        <div class="row"><label>Brush Size</label><input id="brush" type="range" min="6" max="64" step="1" value="26"></div>
        <div class="row"><label>Force</label><input id="force" type="range" min="50" max="1500" step="10" value="900"></div>
        <div class="row"><label>Gravity</label><input id="grav" type="range" min="-900" max="900" step="10" value="120"></div>
        <div class="row"><label>Buoyancy</label><input id="buoy" type="range" min="-2" max="2" step="0.05" value="0.2"></div>
        <div class="switch"><input id="macc" type="checkbox" checked> <label for="macc">MacCormack advection</label></div>
        <div class="switch"><input id="wrap" type="checkbox"> <label for="wrap">Wrap edges</label></div>
        <div class="switch"><input id="pretty" type="checkbox" checked> <label for="pretty">Pretty additives (RGB dye)</label></div>
        <div class="chips">
          <span class="chip" data-preset="calm">Calm Pool</span>
          <span class="chip" data-preset="storm">Stormy</span>
          <span class="chip" data-preset="smoke">Smoky Room</span>
          <span class="chip" data-preset="nebula">Nebula</span>
          <span class="chip" data-preset="ink">Ink Drop</span>
          <span class="chip" data-preset="psy">Psychedelia</span>
        </div>
        <div class="btns">
          <div class="btn" id="clear">Clear</div>
          <div class="btn" id="pause">Pause â–Œâ–Œ</div>
        </div>
        <div class="small">Tip: drag to paint dye & add force. Long-press without moving to just add force (wind). If it jitters on older phones, reduce resolution.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const C = document.getElementById('view');
  const fpsEl = document.getElementById('fps');
  const W = C.getContext('2d', { alpha: false, desynchronized: true });

  // UI
  const ui = {
    res: q('#res'), dt: q('#dt'), visc: q('#visc'), diff: q('#diff'), vort: q('#vort'), brush: q('#brush'),
    force: q('#force'), grav: q('#grav'), buoy: q('#buoy'), macc: q('#macc'), wrap: q('#wrap'),
    pretty: q('#pretty'), clear: q('#clear'), pause: q('#pause')
  };

  // Bottom sheet interactions
  const sheet = q('#sheet');
  const toggleBtn = q('#toggle');
  let open = false;
  const setSheet = v => { open = v; sheet.classList.toggle('open', open); sheet.setAttribute('aria-expanded', open); toggleBtn.textContent = open ? 'Controls â–¾' : 'Controls â–´'; };
  toggleBtn.addEventListener('click', () => setSheet(!open));
  // Drag handle (simple):
  q('.drag').addEventListener('click', () => setSheet(!open));

  // Globals
  let gridN = parseInt(ui.res.value)|0;
  let paused = false;

  // Device pixel ratio handling
  function resize() {
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    const rect = C.parentElement.getBoundingClientRect();
    C.width = rect.width * dpr; C.height = rect.height * dpr; W.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(resize).observe(document.getElementById('canvasWrap'));
  resize();

  // --- Fluid solver (semi-Lagrangian + Jacobi pressure) ---
  // Grid is N x N; we maintain velocity (u,v), pressure, divergence, dye (r,g,b), temperature field for buoyancy.
  function Fluid(N) {
    this.N = N;
    const S = (N+2)*(N+2);
    const Z = () => new Float32Array(S);
    this.u = Z(); this.v = Z(); this.u0 = Z(); this.v0 = Z();
    this.p = Z(); this.div = Z();
    this.r = Z(); this.g = Z(); this.b = Z(); this.r0 = Z(); this.g0 = Z(); this.b0 = Z();
    this.tmp = Z(); this.tmp2 = Z();
    this.t = Z(); this.t0 = Z(); // temperature / smoke for buoyancy
    this.wrap = false;
  }
  const IX = (N,i,j) => i + (N+2)*j;

  Fluid.prototype.addSource = function(x, s, dt) {
    for (let i=0;i<x.length;i++) x[i]+=dt*s[i];
  };

  function diffuse(N, b, x, x0, diff, dt, wrap) {
    const a = dt * diff * N * N;
    for (let k=0;k<20;k++) {
      for (let j=1;j<=N;j++) for (let i=1;i<=N;i++) {
        x[IX(N,i,j)] = (x0[IX(N,i,j)] + a*(x[IX(N,i-1,j)] + x[IX(N,i+1,j)] + x[IX(N,i,j-1)] + x[IX(N,i,j+1)]))/(1+4*a);
      }
      setBnd(N,b,x,wrap);
    }
  }

  function advect(N, b, d, d0, u, v, dt, wrap) {
    const dt0 = dt*N;
    for (let j=1;j<=N;j++) for (let i=1;i<=N;i++) {
      let x = i - dt0*u[IX(N,i,j)];
      let y = j - dt0*v[IX(N,i,j)];
      if (wrap) {
        while (x<0.5) x+=N; while (x> N+0.5) x-=N;
        while (y<0.5) y+=N; while (y> N+0.5) y-=N;
      } else {
        if (x<0.5) x=0.5; if (x> N+0.5) x= N+0.5;
        if (y<0.5) y=0.5; if (y> N+0.5) y= N+0.5;
      }
      const i0=Math.floor(x), i1=i0+1, j0=Math.floor(y), j1=j0+1;
      const s1 = x - i0, s0 = 1 - s1, t1 = y - j0, t0 = 1 - t1;
      d[IX(N,i,j)] = s0*(t0*d0[IX(N,i0,j0)] + t1*d0[IX(N,i0,j1)]) + s1*(t0*d0[IX(N,i1,j0)] + t1*d0[IX(N,i1,j1)]);
    }
    setBnd(N,b,d,wrap);
  }

  function macCormackAdvect(N,b,d,d0,u,v,dt,wrap,tmp,tmp2){
    // Forward advect
    advect(N,b,tmp,d0,u,v,dt,wrap);
    // Backward advect the result
    for(let k=0;k<d0.length;k++) tmp2[k]=tmp[k];
    for (let j=1;j<=N;j++) for (let i=1;i<=N;i++) {
      const idx=IX(N,i,j); const dt0=dt*N;
      let x=i+dt0*u[idx]; let y=j+dt0*v[idx];
      if(wrap){ while(x<0.5) x+=N; while(x>N+0.5) x-=N; while(y<0.5) y+=N; while(y>N+0.5) y-=N; }
      else{ if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; }
      const i0=Math.floor(x),i1=i0+1,j0=Math.floor(y),j1=j0+1;
      const s1=x-i0,s0=1-s1,t1=y-j0,t0=1-t1;
      const back = s0*(t0*tmp2[IX(N,i0,j0)] + t1*tmp2[IX(N,i0,j1)]) + s1*(t0*tmp2[IX(N,i1,j0)] + t1*tmp2[IX(N,i1,j1)];
      // Corrector
      d[idx] = tmp[idx] + 0.5*(d0[idx]-back);
    }
    setBnd(N,b,d,wrap);
  }

  function project(N, u, v, p, div, wrap){
    for (let j=1;j<=N;j++) for (let i=1;i<=N;i++) {
      div[IX(N,i,j)] = -0.5*(u[IX(N,i+1,j)]-u[IX(N,i-1,j)] + v[IX(N,i,j+1)]-v[IX(N,i,j-1)]) / N;
      p[IX(N,i,j)] = 0;
    }
    setBnd(N,0,div,wrap); setBnd(N,0,p,wrap);
    for(let k=0;k<40;k++){
      for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){
        p[IX(N,i,j)] = (div[IX(N,i,j)] + p[IX(N,i-1,j)] + p[IX(N,i+1,j)] + p[IX(N,i,j-1)] + p[IX(N,i,j+1)]) / 4;
      }
      setBnd(N,0,p,wrap);
    }
    for (let j=1;j<=N;j++) for (let i=1;i<=N;i++) {
      u[IX(N,i,j)] -= 0.5*N*(p[IX(N,i+1,j)]-p[IX(N,i-1,j)]);
      v[IX(N,i,j)] -= 0.5*N*(p[IX(N,i,j+1)]-p[IX(N,i,j-1)]);
    }
    setBnd(N,1,u,wrap); setBnd(N,2,v,wrap);
  }

  function vorticityConfinement(N,u,v,eps){
    // Compute curl and add confinement force
    const curl = new Float32Array((N+2)*(N+2));
    for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){
      const c = (v[IX(N,i+1,j)]-v[IX(N,i-1,j)] - (u[IX(N,i,j+1)]-u[IX(N,i,j-1)]))*0.5;
      curl[IX(N,i,j)] = c;
    }
    for(let j=2;j<=N-1;j++) for(let i=2;i<=N-1;i++){
      const idx=IX(N,i,j);
      const Nx = Math.abs(curl[IX(N,i+1,j)]) - Math.abs(curl[IX(N,i-1,j)]);
      const Ny = Math.abs(curl[IX(N,i,j+1)]) - Math.abs(curl[IX(N,i,j-1)]);
      const len = Math.hypot(Nx,Ny)+1e-5;
      const NxN = Nx/len, NyN = Ny/len;
      const force = eps * (1/N);
      u[idx] += force * NyN * curl[idx];
      v[idx] -= force * NxN * curl[idx];
    }
  }

  function setBnd(N, b, x, wrap){
    for(let i=1;i<=N;i++){
      x[IX(N,0,i)]   = wrap ? x[IX(N,N,i)] : (b===1? -x[IX(N,1,i)] : x[IX(N,1,i)]);
      x[IX(N,N+1,i)] = wrap ? x[IX(N,1,i)] : (b===1? -x[IX(N,N,i)] : x[IX(N,N,i)]);
      x[IX(N,i,0)]   = wrap ? x[IX(N,i,N)] : (b===2? -x[IX(N,i,1)] : x[IX(N,i,1)]);
      x[IX(N,i,N+1)] = wrap ? x[IX(N,i,1)] : (b===2? -x[IX(N,i,N)] : x[IX(N,i,N)]);
    }
    x[IX(N,0,0)] = 0.5*(x[IX(N,1,0)] + x[IX(N,0,1)]);
    x[IX(N,0,N+1)] = 0.5*(x[IX(N,1,N+1)] + x[IX(N,0,N)]);
    x[IX(N,N+1,0)] = 0.5*(x[IX(N,N,0)] + x[IX(N,N+1,1)]);
    x[IX(N,N+1,N+1)] = 0.5*(x[IX(N,N,N+1)] + x[IX(N,N+1,N)]);
  }

  Fluid.prototype.step = function(dt, visc, diff, vortAmp, grav, buoy, useMac, pretty){
    const N=this.N; const wrap = this.wrap;
    // Add gravity + buoyancy to v
    if (grav !== 0 || buoy !== 0){
      for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){
        const idx=IX(N,i,j);
        const temp = this.t[idx];
        this.v[idx] += dt*(grav + buoy*temp);
      }
    }

    // Diffuse velocity
    diffuse(N,1,this.u0,this.u,visc,dt,wrap);
    diffuse(N,2,this.v0,this.v,visc,dt,wrap);
    // Project intermediate
    project(N,this.u0,this.v0,this.p,this.div,wrap);

    // Advect velocity
    if(useMac){
      macCormackAdvect(N,1,this.u,this.u0,this.u0,this.v0,dt,wrap,this.tmp,this.tmp2);
      macCormackAdvect(N,2,this.v,this.v0,this.u0,this.v0,dt,wrap,this.tmp,this.tmp2);
    } else {
      advect(N,1,this.u,this.u0,this.u0,this.v0,dt,wrap);
      advect(N,2,this.v,this.v0,this.u0,this.v0,dt,wrap);
    }
    // Project again
    project(N,this.u,this.v,this.p,this.div,wrap);

    // Vorticity confinement
    if(vortAmp>0) vorticityConfinement(N,this.u,this.v,vortAmp);

    // Dye + temperature
    diffuse(N,0,this.r0,this.r,diff,dt,wrap); diffuse(N,0,this.g0,this.g,diff,dt,wrap); diffuse(N,0,this.b0,this.b,diff,dt,wrap); diffuse(N,0,this.t0,this.t,diff,dt,wrap);
    if(useMac){
      macCormackAdvect(N,0,this.r,this.r0,this.u,this.v,dt,wrap,this.tmp,this.tmp2);
      macCormackAdvect(N,0,this.g,this.g0,this.u,this.v,dt,wrap,this.tmp,this.tmp2);
      macCormackAdvect(N,0,this.b,this.b0	this.u,this.v,dt,wrap,this.tmp,this.tmp2);
      macCormackAdvect(N,0,this.t,this.t0	this.u,this.v,dt,wrap,this.tmp,this.tmp2);
    } else {
      advect(N,0,this.r,this.r0,this.u,this.v,dt,wrap);
      advect(N,0,this.g,this.g0,this.u,this.v,dt,wrap);
      advect(N,0,this.b,this.b0,this.u,this.v,dt,wrap);
      advect(N,0,this.t,this.t0,this.u,this.v,dt,wrap);
    }

    // pretty additives â€” slow dye fade
    if (pretty){
      for(let k=0;k<this.r.length;k++){ this.r[k]*=0.999; this.g[k]*=0.999; this.b[k]*=0.999; this.t[k]*=0.9985; }
    }
  };

  // Allocate sim
  let F = new Fluid(gridN);

  function rebuild(N){
    gridN = N; F = new Fluid(gridN); F.wrap = ui.wrap.checked; lastStamp = performance.now();
  }

  // Rendering (downsampled grid -> canvas)
  function draw(){
    const N = F.N; const img = W.getImageData(0,0,C.width,C.height); const data = img.data;
    const cw = C.width, ch = C.height; const gw = N, gh = N; // simple nearest sampling
    for(let y=0;y<ch;y++){
      const gy = 1 + Math.floor((y/ch)*N);
      for(let x=0;x<cw;x++){
        const gx = 1 + Math.floor((x/cw)*N);
        const idxGrid = IX(N,gx,gy);
        const r = F.r[idxGrid], g = F.g[idxGrid], b = F.b[idxGrid];
        const off = (y*cw + x)*4;
        data[off] = Math.max(0,Math.min(255, r*255));
        data[off+1] = Math.max(0,Math.min(255, g*255));
        data[off+2] = Math.max(0,Math.min(255, b*255));
        data[off+3] = 255;
      }
    }
    W.putImageData(img,0,0);
  }

  // Input handling (touch + pointer) â€” optimized for mobile Safari
  let dragging = false, lastX=0, lastY=0, lastTime=0;
  function canvasPos(e){
    const rect = C.getBoundingClientRect();
    const t = e.touches ? e.touches[0] : e;
    const x = (t.clientX - rect.left) / rect.width;
    const y = (t.clientY - rect.top) / rect.height;
    return {x:Math.min(0.999,Math.max(0.001,x)), y:Math.min(0.999,Math.max(0.001,y))};
  }
  function addBrush(x,y,vx,vy){
    const N = F.N; const bs = parseInt(ui.brush.value)|0; const f = parseFloat(ui.force.value);
    const i = 1 + Math.floor(x*N), j = 1 + Math.floor(y*N);
    for(let dy=-bs; dy<=bs; dy++){
      for(let dx=-bs; dx<=bs; dx++){
        if(dx*dx+dy*dy>bs*bs) continue;
        const ii = Math.min(N,Math.max(1,i+dx));
        const jj = Math.min(N,Math.max(1,j+dy));
        const idx = IX(N,ii,jj);
        F.u[idx] += vx * f * 0.0005;
        F.v[idx] += vy * f * 0.0005;
        // colorful dye ring
        const hue = (performance.now()/30 + (ii+jj)*2)%360; const c = hsl(hue, 0.75, 0.5);
        F.r[idx] = Math.min(1, F.r[idx] + c[0]);
        F.g[idx] = Math.min(1, F.g[idx] + c[1]);
        F.b[idx] = Math.min(1, F.b[idx] + c[2]);
        F.t[idx] = Math.min(1, F.t[idx] + 0.6);
      }
    }
  }

  C.addEventListener('touchstart', e=>{ e.preventDefault(); dragging=true; const p=canvasPos(e); lastX=p.x; lastY=p.y; lastTime=performance.now(); addBrush(p.x,p.y,0,0); }, {passive:false});
  C.addEventListener('touchmove', e=>{ e.preventDefault(); if(!dragging) return; const p=canvasPos(e); const now=performance.now(); const dt=(now-lastTime+1e-6); const vx=(p.x-lastX)/dt*16; const vy=(p.y-lastY)/dt*16; addBrush(p.x,p.y,vx,vy); lastX=p.x; lastY=p.y; lastTime=now; }, {passive:false});
  C.addEventListener('touchend', ()=>{ dragging=false; }, {passive:false});
  // Pointer fallback (iPadOS keyboard/mice)
  C.addEventListener('pointerdown', e=>{ if(e.pointerType==='mouse') {dragging=true; const p=canvasPos(e); lastX=p.x; lastY=p.y; lastTime=performance.now(); addBrush(p.x,p.y,0,0);} });
  C.addEventListener('pointermove', e=>{ if(!dragging||e.pointerType!=='mouse') return; const p=canvasPos(e); const now=performance.now(); const dt=(now-lastTime+1e-6); const vx=(p.x-lastX)/dt*16; const vy=(p.y-lastY)/dt*16; addBrush(p.x,p.y,vx,vy); lastX=p.x; lastY=p.y; lastTime=now; });
  window.addEventListener('pointerup', ()=> dragging=false);

  // Controls
  ui.res.addEventListener('change', ()=> rebuild(parseInt(ui.res.value)));
  ui.clear.addEventListener('click', ()=> rebuild(gridN));
  ui.pause.addEventListener('click', ()=>{ paused=!paused; ui.pause.textContent = paused? 'Resume â–¶' : 'Pause â–Œâ–Œ'; });
  ui.wrap.addEventListener('change', ()=> F.wrap = ui.wrap.checked);

  // Presets
  on('.chip', 'click', (el)=>{
    const p = el.dataset.preset;
    if(p==='calm'){ ui.vort.value=20; ui.visc.value=0.0006; ui.diff.value=0.0002; ui.grav.value=40; ui.buoy.value=0.1; ui.force.value=400; ui.brush.value=22; }
    if(p==='storm'){ ui.vort.value=70; ui.visc.value=0.0001; ui.diff.value=0.00005; ui.grav.value=180; ui.buoy.value=0.2; ui.force.value=1200; ui.brush.value=28; }
    if(p==='smoke'){ ui.vort.value=55; ui.visc.value=0.00015; ui.diff.value=0.0003; ui.grav.value=-40; ui.buoy.value=0.5; ui.force.value=800; ui.brush.value=24; }
    if(p==='nebula'){ ui.vort.value=35; ui.visc.value=0.00005; ui.diff.value=0.00025; ui.grav.value=0; ui.buoy.value=0.05; ui.force.value=600; ui.brush.value=26; ui.wrap.checked=true; F.wrap=true; }
    if(p==='ink'){ ui.vort.value=15; ui.visc.value=0.0008; ui.diff.value=0.0008; ui.grav.value=220; ui.buoy.value=0.05; ui.force.value=350; ui.brush.value=18; }
    if(p==='psy'){ ui.vort.value=80; ui.visc.value=0.00005; ui.diff.value=0.00005; ui.grav.value=110; ui.buoy.value=0.3; ui.force.value=1000; ui.brush.value=32; ui.pretty.checked=true; }
  });

  // Utilities
  function q(s){ return document.querySelector(s); }
  function on(sel,evt,fn){ document.querySelectorAll(sel).forEach(el=>el.addEventListener(evt,()=>fn(el))); }
  function hsl(h,s,l){ // return rgb [0..1]
    const c = (1-Math.abs(2*l-1))*s; const x = c*(1-Math.abs((h/60)%2-1)); const m=l-c/2; let r=0,g=0,b=0;
    if (0<=h&&h<60){r=c;g=x;} else if (60<=h&&h<120){r=x;g=c;} else if (120<=h&&h<180){g=c;b=x;} else if (180<=h&&h<240){g=x;b=c;} else if (240<=h&&h<300){r=x;b=c;} else {r=c;b=x;}
    return [r+m,g+m,b+m];
  }

  // Main loop
  let lastStamp = performance.now();
  let fpsSamp = 0, fpsCount = 0;
  function tick(now){
    requestAnimationFrame(tick);
    const dt = Math.min(0.05, parseFloat(ui.dt.value));
    const visc = parseFloat(ui.visc.value), diff = parseFloat(ui.diff.value);
    const vort = parseFloat(ui.vort.value); const grav = parseFloat(ui.grav.value); const buoy = parseFloat(ui.buoy.value);
    if(!paused){ F.step(dt,visc,diff,vort,grav,buoy,ui.macc.checked,ui.pretty.checked); draw(); }

    fpsCount++; if(now-lastStamp>250){ const fps = (fpsCount*1000/(now-lastStamp))|0; fpsEl.textContent = `${fps} fps`; fpsCount=0; lastStamp=now; }
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
