<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Fluid Dynamics â€” Mobile Safari (Smooth Refactor)</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#111827cc;--text:#e5e7eb;--muted:#9ca3af;--accent:#60a5fa;--accent2:#a78bfa;--chip:#1f2937;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased}
    #app{position:fixed;inset:0;display:flex;flex-direction:column}
    header{display:flex;align-items:center;gap:.6rem;padding:.7rem env(safe-area-inset-right) .7rem env(safe-area-inset-left)}
    header h1{font-size:1.05rem;margin:0;letter-spacing:.1px;font-weight:700}
    header .fps{margin-left:auto;font-variant-numeric:tabular-nums;opacity:.85}
    #canvasWrap{position:relative;flex:1;min-height:240px}
    canvas{position:absolute;inset:0;width:100%;height:100%;touch-action:none;background:#070a0f;display:block}

    #fab{position:fixed;right:env(safe-area-inset-right);bottom:calc(1rem + env(safe-area-inset-bottom));z-index:10}
    #fab button{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#fff;border:none;border-radius:999px;padding:.9rem 1.05rem;box-shadow:0 10px 25px #0008;font-weight:700}

    #sheet{position:fixed;left:0;right:0;bottom:0;transform:translateY(100%);transition:.35s transform ease;z-index:20}
    #sheet.open{transform:translateY(0)}
    .sheet-contents{background:var(--panel);backdrop-filter:blur(10px);border-radius:16px 16px 0 0;box-shadow:0 -15px 40px #000c;padding:12px env(safe-area-inset-right) calc(8px + env(safe-area-inset-bottom)) env(safe-area-inset-left)}
    .drag{width:44px;height:4px;background:#ffffff35;border-radius:2px;margin:6px auto 10px}
    .row{display:flex;align-items:center;gap:.5rem;margin:8px 0}
    .row label{flex:0 0 44%;font-size:.86rem;color:var(--muted)}
    .row input[type=range]{flex:1}
    .switch{display:flex;align-items:center;gap:.5rem;margin:6px 0}
    .chips{display:flex;flex-wrap:wrap;gap:.4rem;margin-top:.25rem}
    .chip{background:var(--chip);border-radius:999px;padding:.45rem .65rem;font-size:.82rem;cursor:pointer}
    .controls{max-height:56vh;overflow:auto;-webkit-overflow-scrolling:touch}
    .btns{display:flex;gap:.5rem;margin-top:8px;flex-wrap:wrap}
    .btn{flex:1;background:#1f2937;border:1px solid #ffffff22;border-radius:10px;padding:.6rem .8rem;color:#fff;text-align:center;cursor:pointer}
    .btn.full{flex-basis:100%}
    .small{font-size:.8rem;color:var(--muted)}
    .status{margin-left:.6rem;opacity:.8;font-size:.82rem}
    .err{color:#fca5a5}
    .ok{color:#34d399}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>ðŸŒˆ Fluid Dynamics Visualizer</h1>
      <div class="status" id="testStatus"></div>
      <div class="fps" id="fps">-- fps</div>
    </header>
    <div id="canvasWrap">
      <canvas id="view" aria-label="Fluid simulation"></canvas>
    </div>
  </div>

  <div id="fab"><button id="toggle">Controls â–´</button></div>
  <div id="sheet" aria-live="polite" aria-expanded="false">
    <div class="sheet-contents" id="sheetC">
      <div class="drag"></div>
      <div class="controls" id="controls">
        <div class="row"><label>Resolution</label><input id="res" type="range" min="64" max="256" step="32" value="160"></div>
        <div class="row"><label>Time Step</label><input id="dt" type="range" min="0.004" max="0.033" step="0.001" value="0.016"></div>
        <div class="row"><label>Viscosity</label><input id="visc" type="range" min="0" max="0.003" step="0.0001" value="0.0002"></div>
        <div class="row"><label>Diffusion</label><input id="diff" type="range" min="0" max="0.003" step="0.0001" value="0.0002"></div>
        <div class="row"><label>Vorticity</label><input id="vort" type="range" min="0" max="80" step="1" value="45"></div>
        <div class="row"><label>Brush Size</label><input id="brush" type="range" min="6" max="64" step="1" value="26"></div>
        <div class="row"><label>Force</label><input id="force" type="range" min="50" max="1500" step="10" value="900"></div>
        <div class="row"><label>Gravity</label><input id="grav" type="range" min="-900" max="900" step="10" value="120"></div>
        <div class="row"><label>Buoyancy</label><input id="buoy" type="range" min="-2" max="2" step="0.05" value="0.2"></div>
        <div class="switch"><input id="macc" type="checkbox" checked> <label for="macc">MacCormack advection</label></div>
        <div class="switch"><input id="wrap" type="checkbox"> <label for="wrap">Wrap edges</label></div>
        <div class="switch"><input id="pretty" type="checkbox" checked> <label for="pretty">Pretty additives (RGB dye)</label></div>
        <div class="chips">
          <span class="chip" data-preset="calm">Calm Pool</span>
          <span class="chip" data-preset="storm">Stormy</span>
          <span class="chip" data-preset="smoke">Smoky Room</span>
          <span class="chip" data-preset="nebula">Nebula</span>
          <span class="chip" data-preset="ink">Ink Drop</span>
          <span class="chip" data-preset="psy">Psychedelia</span>
        </div>
        <div class="btns">
          <div class="btn" id="clear">Clear</div>
          <div class="btn" id="pause">Pause â–Œâ–Œ</div>
          <div class="btn full" id="diag">Run Diagnostics</div>
        </div>
        <div class="small">Tip: drag to paint dye & add force. Long-press fades automatically so it doesnâ€™t blow up. If it jitters, reduce resolution.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ============================
  // Utilities
  // ============================
  const clamp=(x,a,b)=>x<a?a:(x>b?b:x);
  const q = (s)=>document.querySelector(s);
  const on=(sel,evt,fn)=>document.querySelectorAll(sel).forEach(el=>el.addEventListener(evt,()=>fn(el)));
  function hsl(h,s,l){ const c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs((h/60)%2-1)), m=l-c/2; let r=0,g=0,b=0; if(0<=h&&h<60){r=c;g=x;} else if(60<=h&&h<120){r=x;g=c;} else if(120<=h&&h<180){g=c;b=x;} else if(180<=h&&h<240){g=x;b=c;} else if(240<=h&&h<300){r=x;b=c;} else {r=c;b=x;} return [r+m,g+m,b+m]; }

  // ============================
  // Canvas & UI
  // ============================
  const C = document.getElementById('view');
  const W = C.getContext('2d', {alpha:false, desynchronized:true});
  const fpsEl = document.getElementById('fps');
  const statusEl = document.getElementById('testStatus');
  const ui = { res:q('#res'), dt:q('#dt'), visc:q('#visc'), diff:q('#diff'), vort:q('#vort'), brush:q('#brush'), force:q('#force'), grav:q('#grav'), buoy:q('#buoy'), macc:q('#macc'), wrap:q('#wrap'), pretty:q('#pretty'), clear:q('#clear'), pause:q('#pause'), diag:q('#diag') };

  // Bottom sheet toggling
  const sheet=q('#sheet'); const toggleBtn=q('#toggle'); let open=false; const setSheet=v=>{ open=v; sheet.classList.toggle('open',open); sheet.setAttribute('aria-expanded', String(open)); toggleBtn.textContent=open?'Controls â–¾':'Controls â–´'; };
  toggleBtn.addEventListener('click', ()=>setSheet(!open)); q('.drag').addEventListener('click', ()=>setSheet(!open));

  // DPI-aware resize
  function resize(){ const dpr=Math.max(1, Math.min(window.devicePixelRatio||1, 2)); const rect=C.parentElement.getBoundingClientRect(); C.width=Math.max(2,rect.width*dpr|0); C.height=Math.max(2,rect.height*dpr|0); W.setTransform(dpr,0,0,dpr,0,0); }
  new ResizeObserver(resize).observe(document.getElementById('canvasWrap')); resize();

  // ============================
  // Stable Fluid Solver (mobile-safe)
  // ============================
  class Fluid{
    constructor(n, wrap=false){ this.setResolution(n, wrap); this.diff=2e-4; this.visc=2e-4; this.dt=0.016; this.vort=20; this.confine=true; this.buoy=0.12; this.advectMac=true; this.gravY=0.12/1000; this.pretty=true; }
    setResolution(n, wrap){ this.n=n|0; this.wrap=!!wrap; const N=this.n, S=(N+2)*(N+2); const Z=()=>new Float32Array(S); this.u=Z(); this.v=Z(); this.u0=Z(); this.v0=Z(); this.p=Z(); this.div=Z(); this.r=Z(); this.g=Z(); this.b=Z(); this.r0=Z(); this.g0=Z(); this.b0=Z(); this.tmp=Z(); }
    IX(x,y){ return x + (this.n+2)*y; }
    setBnd(b,x){ const N=this.n; for(let i=1;i<=N;i++){ x[this.IX(0,i)]=this.wrap?x[this.IX(N,i)]:(b===1?-x[this.IX(1,i)]:x[this.IX(1,i)]); x[this.IX(N+1,i)]=this.wrap?x[this.IX(1,i)]:(b===1?-x[this.IX(N,i)]:x[this.IX(N,i)]); x[this.IX(i,0)]=this.wrap?x[this.IX(i,N)]:(b===2?-x[this.IX(i,1)]:x[this.IX(i,1)]); x[this.IX(i,N+1)]=this.wrap?x[this.IX(i,1)]:(b===2?-x[this.IX(i,N)]:x[this.IX(i,N)]);} x[this.IX(0,0)]=.5*(x[this.IX(1,0)]+x[this.IX(0,1)]); x[this.IX(0,N+1)]=.5*(x[this.IX(1,N+1)]+x[this.IX(0,N)]); x[this.IX(N+1,0)]=.5*(x[this.IX(N,0)]+x[this.IX(N+1,1)]); x[this.IX(N+1,N+1)]=.5*(x[this.IX(N,N+1)]+x[this.IX(N+1,N)]); }
    addSource(x,s,dt){ for(let i=0;i<x.length;i++) x[i]+=dt*s[i]; }
    linSolve(b,x,x0,a,c){ const N=this.n,cR=1/c; for(let k=0;k<18;k++){ for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){ x[this.IX(i,j)] = (x0[this.IX(i,j)] + a*(x[this.IX(i-1,j)] + x[this.IX(i+1,j)] + x[this.IX(i,j-1)] + x[this.IX(i,j+1)]))*cR; } this.setBnd(b,x); } }
    diffuse(b,x,x0,diff,dt){ const a=dt*diff*this.n*this.n; this.linSolve(b,x,x0,a,1+4*a); }
    advect(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N; for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){
        let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)];
        if(this.wrap){ while(x<0.5)x+=N; while(x>N+0.5)x-=N; while(y<0.5)y+=N; while(y>N+0.5)y-=N; }
        else { if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; }
        const i0=x|0,i1=i0+1,j0=y|0,j1=j0+1; const s1=x-i0,s0=1-s1,t1=y-j0,t0=1-t1;
        d[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);
      }
      this.setBnd(b,d);
    }
    advectMacCormack(b,d,d0,u,v,dt){ const N=this.n, dt0=dt*N, phi=this.tmp; // forward
      for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){
        let x=i-dt0*u[this.IX(i,j)], y=j-dt0*v[this.IX(i,j)];
        if(this.wrap){ while(x<0.5)x+=N; while(x>N+0.5)x-=N; while(y<0.5)y+=N; while(y>N+0.5)y-=N; }
        else { if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; }
        const i0=x|0,i1=i0+1,j0=y|0,j1=j0+1; const s1=x-i0,s0=1-s1,t1=y-j0,t0=1-t1;
        phi[this.IX(i,j)] = s0*(t0*d0[this.IX(i0,j0)] + t1*d0[this.IX(i0,j1)]) + s1*(t0*d0[this.IX(i1,j0)] + t1*d0[this.IX(i1,j1)]);
      }
      this.setBnd(b,phi);
      for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){
        let x=i+dt0*u[this.IX(i,j)], y=j+dt0*v[this.IX(i,j)];
        if(this.wrap){ while(x<0.5)x+=N; while(x>N+0.5)x-=N; while(y<0.5)y+=N; while(y>N+0.5)y-=N; }
        else { if(x<0.5)x=0.5; if(x>N+0.5)x=N+0.5; if(y<0.5)y=0.5; if(y>N+0.5)y=N+0.5; }
        const i0=x|0,i1=i0+1,j0=y|0,j1=j0+1; const s1=x-i0,s0=1-s1,t1=y-j0,t0=1-t1;
        const back = s0*(t0*phi[this.IX(i0,j0)] + t1*phi[this.IX(i0,j1)]) + s1*(t0*phi[this.IX(i1,j0)] + t1*phi[this.IX(i1,j1)]);
        const ph = phi[this.IX(i,j)], d0ij = d0[this.IX(i,j)];
        d[this.IX(i,j)] = clamp(ph + 0.5*(d0ij - back), Math.min(d0ij, ph), Math.max(d0ij, ph));
      }
      this.setBnd(b,d);
    }
    project(u,v,p,div){ const N=this.n, IX=this.IX.bind(this); for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){ div[IX(i,j)] = -0.5*(u[IX(i+1,j)]-u[IX(i-1,j)] + v[IX(i,j+1)]-v[IX(i,j-1)]) / N; p[IX(i,j)] = 0; } this.setBnd(0,div); this.setBnd(0,p); for(let k=0;k<20;k++){ for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){ p[IX(i,j)] = (div[IX(i,j)] + p[IX(i-1,j)] + p[IX(i+1,j)] + p[IX(i,j-1)] + p[IX(i,j+1)]) / 4; } this.setBnd(0,p); } for(let j=1;j<=N;j++) for(let i=1;i<=N;i++){ u[IX(i,j)] -= 0.5*N*(p[IX(i+1,j)]-p[IX(i-1,j)]); v[IX(i,j)] -= 0.5*N*(p[IX(i,j+1)]-p[IX(i,j-1)]); } this.setBnd(1,u); this.setBnd(2,v); }
    vorticityConfinement(u,v,eps){ const N=this.n, IX=this.IX.bind(this); for(let i=2;i<=N-1;i++) for(let j=2;j<=N-1;j++){ const dw_dx = Math.abs(v[IX(i+1,j)] - v[IX(i-1,j)])*0.5; const dw_dy = Math.abs(u[IX(i,j+1)] - u[IX(i,j-1)])*0.5; const len = Math.sqrt(dw_dx*dw_dx + dw_dy*dw_dy) + 1e-6; const Nx = dw_dx/len, Ny = dw_dy/len; const w = (v[IX(i+1,j)] - v[IX(i-1,j)] - (u[IX(i,j+1)] - u[IX(i,j-1)]))*0.5; this.u[IX(i,j)] += eps * (Ny * w); this.v[IX(i,j)] += eps * (-Nx * w); } this.setBnd(1,this.u); this.setBnd(2,this.v); }
    step(){ const N=this.n, dt=this.dt; const u=this.u,v=this.v,u0=this.u0,v0=this.v0, r=this.r,g=this.g,b=this.b, r0=this.r0,g0=this.g0,b0=this.b0; // buoyancy/gravity
      if(this.gravY!==0){ for(let i=0;i<u.length;i++) v[i]+=this.gravY*dt/N; }
      if(this.buoy>0){ for(let i=0;i<r.length;i++){ const density=(r[i]+g[i]+b[i])*(1/3); v[i]+= -this.buoy*density*dt; }}
      // velocity
      this.diffuse(1,u0,u,this.visc,dt); this.diffuse(2,v0,v,this.visc,dt); this.project(u0,v0,this.p,this.div);
      if(this.advectMac){ this.advectMacCormack(1,u,u0,u0,v0,dt); this.advectMacCormack(2,v,v0,u0,v0,dt);} else { this.advect(1,u,u0,u0,v0,dt); this.advect(2,v,v0,u0,v0,dt);} this.project(u,v,this.p,this.div);
      if(this.confine && this.vort>0) this.vorticityConfinement(u,v,this.vort*dt*0.0015);
      // dye
      this.diffuse(0,r0,r,this.diff,dt); this.diffuse(0,g0,g,this.diff,dt); this.diffuse(0,b0,b,this.diff,dt);
      if(this.advectMac){ this.advectMacCormack(0,r,r0,u,v,dt); this.advectMacCormack(0,g,g0,u,v,dt); this.advectMacCormack(0,b,b0,u,v,dt);} else { this.advect(0,r,r0,u,v,dt); this.advect(0,g,g0,u,v,dt); this.advect(0,b,b0,u,v,dt);} const decay=this.pretty?0.9994:1.0; if(decay!==1){ for(let i=0;i<r.length;i++){ r[i]*=decay; g[i]*=decay; b[i]*=decay; }} u0.fill(0); v0.fill(0); r0.fill(0); g0.fill(0); b0.fill(0); }
  }

  // Allocate sim
  let fluid = new Fluid(parseInt(ui.res.value,10));
  function rebuild(N){ fluid=new Fluid(N, ui.wrap.checked); lastStamp=performance.now(); }

  // ============================
  // Rendering
  // ============================
  function draw(){ const N=fluid.n; const img=W.getImageData(0,0,C.width,C.height); const data=img.data; const cw=C.width,ch=C.height; for(let y=0;y<ch;y++){ const gy=1+((y/ch)*N|0); for(let x=0;x<cw;x++){ const gx=1+((x/cw)*N|0); const idx=fluid.IX(gx,gy); const r=fluid.r[idx], g=fluid.g[idx], b=fluid.b[idx]; const off=(y*cw+x)*4; data[off]=Math.max(0,Math.min(255,(r*255)|0)); data[off+1]=Math.max(0,Math.min(255,(g*255)|0)); data[off+2]=Math.max(0,Math.min(255,(b*255)|0)); data[off+3]=255; }} W.putImageData(img,0,0); }

  // ============================
  // Input (touch + mouse)
  // ============================
  let dragging=false, lastX=0, lastY=0, lastTime=0, dragStart=0, strokeDx=0, strokeDy=0;
  function canvasPos(e){ const rect=C.getBoundingClientRect(); const t=e.touches? e.touches[0]: e; const x=(t.clientX-rect.left)/rect.width; const y=(t.clientY-rect.top)/rect.height; return {x:Math.min(0.999,Math.max(0.001,x)), y:Math.min(0.999,Math.max(0.001,y))}; }

  // Simple safety caps
  const PER_FRAME_VEL=1.2, PER_FRAME_DYE=0.08, VEL_MAX=6.0, DYE_MAX=1.4, CFL=0.9;
  function clampFields(){ const L=fluid.u.length; for(let k=0;k<L;k++){ const ux=fluid.u[k], vy=fluid.v[k], m=Math.hypot(ux,vy); if(m>VEL_MAX){ const s=VEL_MAX/m; fluid.u[k]=ux*s; fluid.v[k]=vy*s; } if(fluid.r[k]>DYE_MAX) fluid.r[k]=DYE_MAX; if(fluid.g[k]>DYE_MAX) fluid.g[k]=DYE_MAX; if(fluid.b[k]>DYE_MAX) fluid.b[k]=DYE_MAX; if(fluid.r[k]<0) fluid.r[k]=0; if(fluid.g[k]<0) fluid.g[k]=0; if(fluid.b[k]<0) fluid.b[k]=0; } }

  function addBrush(x,y,vx,vy){ const N=fluid.n; const bs=parseInt(ui.brush.value,10)|0; const f=parseFloat(ui.force.value); const now=performance.now(); const age=Math.max(0, now - dragStart); let att=1/(1+0.003*age); if(Math.hypot(vx,vy)<0.002) att*=0.25; const i=1+(x*N|0), j=1+(y*N|0);
    for(let dy=-bs; dy<=bs; dy++) for(let dx=-bs; dx<=bs; dx++){
      if(dx*dx+dy*dy>bs*bs) continue; const ii=Math.min(N,Math.max(1,i+dx)), jj=Math.min(N,Math.max(1,j+dy)); const idx=fluid.IX(ii,jj);
      let du=vx*f*0.0005*att, dv=vy*f*0.0005*att; const mag=Math.hypot(du,dv); if(mag>PER_FRAME_VEL){ const s=PER_FRAME_VEL/mag; du*=s; dv*=s; }
      fluid.u0[idx]+=du; fluid.v0[idx]+=dv;
      const H=(now/30 + (ii+jj)*2)%360; const c=hsl(H,0.75,0.5); let rr=c[0]*att, gg=c[1]*att, bb=c[2]*att; const sum=rr+gg+bb; if(sum>PER_FRAME_DYE){ const s=PER_FRAME_DYE/sum; rr*=s; gg*=s; bb*=s; }
      fluid.r0[idx]+=rr; fluid.g0[idx]+=gg; fluid.b0[idx]+=bb;
    }
  }

  C.addEventListener('touchstart', e=>{ e.preventDefault(); dragging=true; const p=canvasPos(e); lastX=p.x; lastY=p.y; const now=performance.now(); lastTime=now; dragStart=now; addBrush(p.x,p.y,0,0); }, {passive:false});
  C.addEventListener('touchmove', e=>{ e.preventDefault(); if(!dragging) return; const p=canvasPos(e); const now=performance.now(); const dt=(now-lastTime+1e-6); const vx=(p.x-lastX)/dt*16; const vy=(p.y-lastY)/dt*16; addBrush(p.x,p.y,vx,vy); lastX=p.x; lastY=p.y; lastTime=now; }, {passive:false});
  C.addEventListener('touchend', ()=>{ dragging=false; }, {passive:false});
  C.addEventListener('pointerdown', e=>{ if(e.pointerType==='mouse'){ dragging=true; const p=canvasPos(e); lastX=p.x; lastY=p.y; const now=performance.now(); lastTime=now; dragStart=now; addBrush(p.x,p.y,0,0);} });
  C.addEventListener('pointermove', e=>{ if(!dragging||e.pointerType!=='mouse') return; const p=canvasPos(e); const now=performance.now(); const dt=(now-lastTime+1e-6); const vx=(p.x-lastX)/dt*16; const vy=(p.y-lastY)/dt*16; addBrush(p.x,p.y,vx,vy); lastX=p.x; lastY=p.y; lastTime=now; });
  window.addEventListener('pointerup', ()=>{ dragging=false; });

  // ============================
  // Controls & presets
  // ============================
  ui.res.addEventListener('change', ()=> rebuild(parseInt(ui.res.value,10)) );
  ui.clear.addEventListener('click', ()=>{ fluid.u.fill(0); fluid.v.fill(0); fluid.r.fill(0); fluid.g.fill(0); fluid.b.fill(0); });
  let paused=false; ui.pause.addEventListener('click', ()=>{ paused=!paused; ui.pause.textContent = paused? 'Resume â–¶':'Pause â–Œâ–Œ'; });
  ui.wrap.addEventListener('change', ()=>{ fluid.wrap = ui.wrap.checked; });
  on('.chip','click', el=>{ const p=el.dataset.preset; if(p==='calm'){ ui.vort.value=20; ui.visc.value=0.0006; ui.diff.value=0.0002; ui.grav.value=40; ui.buoy.value=0.1; ui.force.value=400; ui.brush.value=22; }
    if(p==='storm'){ ui.vort.value=70; ui.visc.value=0.0001; ui.diff.value=0.00005; ui.grav.value=180; ui.buoy.value=0.2; ui.force.value=1200; ui.brush.value=28; }
    if(p==='smoke'){ ui.vort.value=55; ui.visc.value=0.00015; ui.diff.value=0.0003; ui.grav.value=-40; ui.buoy.value=0.5; ui.force.value=800; ui.brush.value=24; }
    if(p==='nebula'){ ui.vort.value=35; ui.visc.value=0.00005; ui.diff.value=0.00025; ui.grav.value=0; ui.buoy.value=0.05; ui.force.value=600; ui.brush.value=26; ui.wrap.checked=true; fluid.wrap=true; }
    if(p==='ink'){ ui.vort.value=15; ui.visc.value=0.0008; ui.diff.value=0.0008; ui.grav.value=220; ui.buoy.value=0.05; ui.force.value=350; ui.brush.value=18; }
    if(p==='psy'){ ui.vort.value=80; ui.visc.value=0.00005; ui.diff.value=0.00005; ui.grav.value=110; ui.buoy.value=0.3; ui.force.value=1000; ui.brush.value=32; ui.pretty.checked=true; }
  });

  // ============================
  // Diagnostics (light tests)
  // ============================
  function runDiagnostics(){ const results=[]; const ok=(name,cond)=>{ results.push([name,!!cond]); if(!cond) console.error('Test failed:',name); };
    ok('IX monotonic',(()=>{ const N=8, f=new Fluid(N); return f.IX(2,3)<f.IX(3,3) && f.IX(1,1)<f.IX(1,2); })());
    ok('Advect zero-vel stable',(()=>{ const f=new Fluid(8); for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) f.r0[f.IX(i,j)]=i+j; f.advect(0,f.r,f.r0,f.u,f.v,0.016); return Math.abs(f.r[f.IX(4,4)]-f.r0[f.IX(4,4)])<1e-3; })());
    ok('Projection reduces div',(()=>{ const f=new Fluid(8); for(let j=1;j<=8;j++) for(let i=1;i<=8;i++){ f.u[f.IX(i,j)]=(i%3)-1; f.v[f.IX(i,j)]=(j%2)-0.5; } let before=0,after=0; for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) before+=Math.abs((f.u[f.IX(i+1,j)]-f.u[f.IX(i-1,j)] + f.v[f.IX(i,j+1)]-f.v[f.IX(i,j-1)])/(2*8)); f.project(f.u,f.v,f.p,f.div); for(let j=1;j<=8;j++) for(let i=1;i<=8;i++) after+=Math.abs((f.u[f.IX(i+1,j)]-f.u[f.IX(i-1,j)] + f.v[f.IX(i,j+1)]-f.v[f.IX(i,j-1)])/(2*8)); return after<before; })());
    ok('Step finite',(()=>{ const f=new Fluid(16); f.r.fill(0.1); f.g.fill(0.2); f.b.fill(0.3); f.step(); for(let k=0;k<f.r.length;k++) if(!isFinite(f.r[k]+f.g[k]+f.b[k])) return false; return true; })());
    // Extra tests
    ok('MacCormack ~ Semi-Lag at zero velocity',(()=>{ const f=new Fluid(10); f.advectMac=true; const src=new Float32Array((12)*(12)); for(let j=1;j<=10;j++) for(let i=1;i<=10;i++) src[f.IX(i,j)]=Math.sin(i*0.3)+Math.cos(j*0.2); f.r0.set(src); f.advectMacCormack(0,f.r,f.r0,f.u,f.v,0.02); const a=f.r[f.IX(5,5)]; f.r.fill(0); f.advect(0,f.r,src,f.u,f.v,0.02); const b=f.r[f.IX(5,5)]; return Math.abs(a-b)<1e-5; })());
    ok('Wrap edges copies across boundary',(()=>{ const f=new Fluid(8); f.wrap=true; f.r[f.IX(1,4)]=1; f.setBnd(0,f.r); return f.r[f.IX(9,4)]===1; })());

    const passed = results.every(r=>r[1]); statusEl.textContent=passed?'Diagnostics: PASS':'Diagnostics: FAIL'; statusEl.className='status '+(passed?'ok':'err'); console.table(results.map(([name,ok])=>({test:name,ok}))); return passed; }
  ui.diag.addEventListener('click', runDiagnostics);

  // ============================
  // Main loop
  // ============================
  let lastStamp=performance.now(), frames=0;
  function tick(now){ requestAnimationFrame(tick);
    // UI -> params
    fluid.dt   = Math.min(0.05, parseFloat(ui.dt.value));
    fluid.visc = parseFloat(ui.visc.value);
    fluid.diff = parseFloat(ui.diff.value);
    fluid.vort = parseFloat(ui.vort.value);
    fluid.gravY= parseFloat(ui.grav.value)/1000;
    fluid.buoy = parseFloat(ui.buoy.value);
    fluid.advectMac = ui.macc.checked; fluid.wrap = ui.wrap.checked; fluid.pretty = ui.pretty.checked;

    // CFL guard â€” sample flow & reduce dt if needed
    { const N=fluid.n; let vmax=0; const L=fluid.u.length; const stride=Math.max(1,(L/4096)|0); for(let k=0;k<L;k+=stride){ const m=Math.hypot(fluid.u[k],fluid.v[k]); if(m>vmax) vmax=m; } if(vmax>1e-6){ const maxDt=CFL/(N*vmax); fluid.dt = Math.min(fluid.dt, Math.max(0.004, maxDt)); } }

    // Add sources from brush (and clear immediately to avoid runaway on slow frames)
    fluid.addSource(fluid.u, fluid.u0, 1); fluid.addSource(fluid.v, fluid.v0, 1);
    fluid.addSource(fluid.r, fluid.r0, 1); fluid.addSource(fluid.g, fluid.g0, 1); fluid.addSource(fluid.b, fluid.b0, 1);
    fluid.u0.fill(0); fluid.v0.fill(0); fluid.r0.fill(0); fluid.g0.fill(0); fluid.b0.fill(0);

    // Soft clamp live fields
    clampFields();

    if(!paused){ fluid.step(); draw(); }

    frames++; if(now-lastStamp>250){ const fps=(frames*1000/(now-lastStamp))|0; fpsEl.textContent=`${fps} fps`; frames=0; lastStamp=now; }
  }
  requestAnimationFrame(tick);

  // Error surfacing
  window.addEventListener('error', (e)=>{ statusEl.textContent = 'Error: '+(e.message||'unknown'); statusEl.className='status err'; });
})();
</script>
</body>
</html>
